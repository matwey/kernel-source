From 0f5d42b287f32417e54485d79f2318cf2970b37d Mon Sep 17 00:00:00 2001
From: Josef Bacik <jbacik@fusionio.com>
Date: Thu, 31 Jan 2013 10:23:04 -0500
Subject: Btrfs: remove extent mapping if we fail to add chunk
Git-commit: 0f5d42b287f32417e54485d79f2318cf2970b37d
Patch-mainline: v3.9-rc1

I got a double free error when unmounting a file system that failed to add a
chunk during its operation.  This is because we will kfree the mapping that
we created but leave the extent_map in the em_tree for chunks.  So to fix
this just remove the extent_map when we error out so we don't run into this
problem.  Thanks,

Signed-off-by: Josef Bacik <jbacik@fusionio.com>
Acked-by: Jeff Mahoney <jeffm@suse.com>
---
 fs/btrfs/volumes.c |   14 ++++++++++++--
 1 file changed, 12 insertions(+), 2 deletions(-)

--- a/fs/btrfs/volumes.c	2013-07-11 17:33:09.876518175 -0400
+++ b/fs/btrfs/volumes.c	2013-07-11 17:34:33.236756435 -0400
@@ -3907,9 +3907,10 @@ static int __btrfs_alloc_chunk(struct bt
 	write_lock(&em_tree->lock);
 	ret = add_extent_mapping(em_tree, em);
 	write_unlock(&em_tree->lock);
-	free_extent_map(em);
-	if (ret)
+	if (ret) {
+		free_extent_map(em);
 		goto error;
+	}
 
 	for (i = 0; i < map->num_stripes; ++i) {
 		struct btrfs_device *device;
@@ -3934,6 +3935,7 @@ static int __btrfs_alloc_chunk(struct bt
 		goto error_dev_extent;
 	}
 
+	free_extent_map(em);
 	check_raid56_incompat_flag(extent_root->fs_info, type);
 
 	kfree(devices_info);
@@ -3951,6 +3953,14 @@ error_dev_extent:
 			break;
 		}
 	}
+	write_lock(&em_tree->lock);
+	remove_extent_mapping(em_tree, em);
+	write_unlock(&em_tree->lock);
+
+	/* One for our allocation */
+	free_extent_map(em);
+	/* One for the tree reference */
+	free_extent_map(em);
 error:
 	kfree(map);
 	kfree(devices_info);
