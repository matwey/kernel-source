From a9870c0e031527fbfa382019f30d2e9b98124a0d Mon Sep 17 00:00:00 2001
From: Wang Shilong <wangsl-fnst@cn.fujitsu.com>
Date: Fri, 1 Mar 2013 11:33:01 +0000
Subject: Btrfs: don't call btrfs_qgroup_free if just btrfs_qgroup_reserve fails
Git-commit: a9870c0e031527fbfa382019f30d2e9b98124a0d
Patch-mainline: v3.9-rc1

commit eb6b88d92c6df083dd09a8c471011e3788dfd7c6 leads into another bug.
If it is just because qgroup_reserve fails, the function btrfs_qgroup_free
should not be called, otherwise, it will cause the wrong quota accounting.

Signed-off-by: Wang Shilong <wangsl-fnst@cn.fujitsu.com>
Signed-off-by: Josef Bacik <jbacik@fusionio.com>
Acked-by: Jeff Mahoney <jeffm@suse.com>
---
 fs/btrfs/extent-tree.c | 11 ++++++-----
 1 file changed, 6 insertions(+), 5 deletions(-)

diff --git a/fs/btrfs/extent-tree.c b/fs/btrfs/extent-tree.c
index 7cb9d73..075854e 100644
--- a/fs/btrfs/extent-tree.c
+++ b/fs/btrfs/extent-tree.c
@@ -4772,9 +4772,14 @@ int btrfs_delalloc_reserve_metadata(struct inode *inode, u64 num_bytes)
 	 * ret != 0 here means the qgroup reservation failed, we go straight to
 	 * the shared error handling then.
 	 */
-	if (ret == 0)
+	if (ret == 0) {
 		ret = reserve_metadata_bytes(root, block_rsv,
 					     to_reserve, flush);
+		if (ret && root->fs_info->quota_enabled) {
+			btrfs_qgroup_free(root, num_bytes +
+						nr_extents * root->leafsize);
+		}
+	}
 
 	if (ret) {
 		u64 to_free = 0;
@@ -4805,10 +4810,6 @@ int btrfs_delalloc_reserve_metadata(struct inode *inode, u64 num_bytes)
 						      btrfs_ino(inode),
 						      to_free, 0);
 		}
-		if (root->fs_info->quota_enabled) {
-			btrfs_qgroup_free(root, num_bytes +
-						nr_extents * root->leafsize);
-		}
 		if (delalloc_lock)
 			mutex_unlock(&BTRFS_I(inode)->delalloc_mutex);
 		return ret;

