From: Jeff Mahoney <jeffm@suse.com>
Subject: reiserfs: fix problems with chowning setuid file w/ xattrs
References: bnc#790920
Patch-mainline: Submitted to reiserfs-devel 27 Nov 2012

reiserfs_chown_xattrs() takes the iattr struct passed into ->setattr
and uses it to iterate over all the attrs associated with a file to change
ownership of xattrs (and transfer quota associated with the xattr files).

When the setuid bit is cleared during chown, ATTR_MODE and iattr->ia_mode
are passed to all the xattrs as well. This means that the xattr directory
will have S_IFREG added to its mode bits.

This has been prevented in practice by a missing IS_PRIVATE check
in reiserfs_acl_chmod, which caused a double-lock to occur while holding
the write lock. Since the file system was completely locked up, the
writeout of the corrupted mode never happened.

This patch temporarily clears everything but ATTR_UID|ATTR_GID for the
calls to reiserfs_setattr and adds the missing IS_PRIVATE check.

Signed-off-by: Jeff Mahoney <jeffm@suse.com>
---
 fs/reiserfs/xattr.c     |   14 +++++++++++++-
 fs/reiserfs/xattr_acl.c |    3 +++
 2 files changed, 16 insertions(+), 1 deletion(-)

--- a/fs/reiserfs/xattr.c	2013-05-31 16:06:35.707599714 -0400
+++ b/fs/reiserfs/xattr.c	2013-05-31 16:06:59.779654391 -0400
@@ -318,7 +318,19 @@ static int delete_one_xattr(struct dentr
 static int chown_one_xattr(struct dentry *dentry, void *data)
 {
 	struct iattr *attrs = data;
-	return reiserfs_setattr(dentry, attrs);
+	int ia_valid = attrs->ia_valid;
+	int err;
+
+	/*
+	 * We only want the ownership bits. Otherwise, we'll do
+	 * things like change a directory to a regular file if
+	 * ATTR_MODE is set.
+	 */
+	attrs->ia_valid &= (ATTR_UID|ATTR_GID);
+	err = reiserfs_setattr(dentry, attrs);
+	attrs->ia_valid = ia_valid;
+
+	return err;
 }
 
 /* No i_mutex, but the inode is unconnected. */
--- a/fs/reiserfs/xattr_acl.c	2013-05-31 16:06:35.707599714 -0400
+++ b/fs/reiserfs/xattr_acl.c	2013-05-31 16:06:59.779654391 -0400
@@ -429,6 +429,9 @@ int reiserfs_acl_chmod(struct inode *ino
 	int depth;
 	int error;
 
+	if (IS_PRIVATE(inode))
+		return 0;
+
 	if (S_ISLNK(inode->i_mode))
 		return -EOPNOTSUPP;
 
