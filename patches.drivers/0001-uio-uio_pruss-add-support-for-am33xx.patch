From e4256fa7372086088e293c6071d85db6a662bedb Mon Sep 17 00:00:00 2001
From: Matt Porter <mporter@ti.com>
Date: Fri, 28 Sep 2012 15:37:47 -0400
Subject: [PATCH 1/4] uio: uio_pruss: add support for am33xx
Patch-mainline: not yet

Adds DT, pinctrl, and runtime PM support to enable AM33xx.

Signed-off-by: Matt Porter <mporter@ti.com>
---
 drivers/uio/Kconfig     |  2 +-
 drivers/uio/uio_pruss.c | 88 +++++++++++++++++++++++++++++++++++++++----------
 2 files changed, 71 insertions(+), 19 deletions(-)

diff --git a/drivers/uio/Kconfig b/drivers/uio/Kconfig
index 52c98ce..05400bc 100644
--- a/drivers/uio/Kconfig
+++ b/drivers/uio/Kconfig
@@ -129,7 +129,7 @@ config UIO_PRUSS
 	select GENERIC_ALLOCATOR
 	depends on HAS_IOMEM && HAS_DMA
 	help
-	  PRUSS driver for OMAPL138/DA850/AM18XX devices
+	  PRUSS driver for OMAPL138/DA850/AM18XX and AM33XX devices
 	  PRUSS driver requires user space components, examples and user space
 	  driver is available from below SVN repo - you may use anonymous login
 
diff --git a/drivers/uio/uio_pruss.c b/drivers/uio/uio_pruss.c
index ca9e2fa..7741fc1 100644
--- a/drivers/uio/uio_pruss.c
+++ b/drivers/uio/uio_pruss.c
@@ -27,6 +27,11 @@
 #include <linux/sizes.h>
 #include <linux/slab.h>
 #include <linux/genalloc.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/err.h>
+#include <linux/pm_runtime.h>
 
 #define DRV_NAME "pruss_uio"
 #define DRV_VERSION "1.0"
@@ -120,9 +125,11 @@ static int pruss_probe(struct platform_device *pdev)
 	struct uio_info *p;
 	struct uio_pruss_dev *gdev;
 	struct resource *regs_prussio;
+	struct resource res;
 	struct device *dev = &pdev->dev;
 	int ret = -ENODEV, cnt = 0, len;
 	struct uio_pruss_pdata *pdata = dev_get_platdata(dev);
+	struct pinctrl *pinctrl;
 
 	gdev = kzalloc(sizeof(struct uio_pruss_dev), GFP_KERNEL);
 	if (!gdev)
@@ -134,17 +141,49 @@ static int pruss_probe(struct platform_device *pdev)
 		return -ENOMEM;
 	}
 
-	/* Power on PRU in case its not done as part of boot-loader */
-	gdev->pruss_clk = clk_get(dev, "pruss");
-	if (IS_ERR(gdev->pruss_clk)) {
-		dev_err(dev, "Failed to get clock\n");
-		ret = PTR_ERR(gdev->pruss_clk);
-		kfree(gdev->info);
-		kfree(gdev);
-		return ret;
+	if (dev->of_node) {
+		pm_runtime_enable(dev);
+		ret = pm_runtime_get_sync(dev);
+		if (IS_ERR_VALUE(ret)) {
+			dev_err(dev, "pm_runtime_get_sync() failed\n");
+			return ret;
+		}
+
+		ret = of_address_to_resource(dev->of_node, 0, &res);
+		if (IS_ERR_VALUE(ret)) {
+			dev_err(dev, "failed to parse DT reg\n");
+			return ret;
+		}
+		regs_prussio = &res;
+
+		ret = of_property_read_u32(dev->of_node,
+					   "ti,pintc-offset",
+					   &gdev->pintc_base);
+		if (ret < 0) {
+			dev_err(dev,
+				"Can't parse ti,pintc-offset property\n");
+			goto out_free;
+		}
 	} else {
-		clk_enable(gdev->pruss_clk);
-	}
+		/* Power on PRU in case its not done as part of boot-loader */
+		gdev->pruss_clk = clk_get(dev, "pruss");
+		if (IS_ERR(gdev->pruss_clk)) {
+			dev_err(dev, "Failed to get clock\n");
+			kfree(gdev->info);
+			kfree(gdev);
+			ret = PTR_ERR(gdev->pruss_clk);
+			return ret;
+		} else {
+			clk_enable(gdev->pruss_clk);
+		}
+		gdev->pintc_base = pdata->pintc_base;
+		gdev->sram_pool = pdata->sram_pool;
+ 	}
+
+	pinctrl = devm_pinctrl_get_select_default(dev);
+	if (IS_ERR(pinctrl))
+		dev_warn(dev,
+			"pins are not configured from the driver\n");
 
 	regs_prussio = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (!regs_prussio) {
@@ -182,7 +221,6 @@ static int pruss_probe(struct platform_device *pdev)
 		goto out_free;
 	}
 
-	gdev->pintc_base = pdata->pintc_base;
 	gdev->hostirq_start = platform_get_irq(pdev, 0);
 
 	for (cnt = 0, p = gdev->info; cnt < MAX_PRUSS_EVT; cnt++, p++) {
@@ -190,13 +228,19 @@ static int pruss_probe(struct platform_device *pdev)
 		p->mem[0].size = resource_size(regs_prussio);
 		p->mem[0].memtype = UIO_MEM_PHYS;
 
-		p->mem[1].addr = gdev->sram_paddr;
-		p->mem[1].size = sram_pool_sz;
-		p->mem[1].memtype = UIO_MEM_PHYS;
-
-		p->mem[2].addr = gdev->ddr_paddr;
-		p->mem[2].size = extram_pool_sz;
-		p->mem[2].memtype = UIO_MEM_PHYS;
+		if (gdev->sram_vaddr) {
+			p->mem[1].addr = gdev->sram_paddr;
+			p->mem[1].size = sram_pool_sz;
+			p->mem[1].memtype = UIO_MEM_PHYS;
+
+			p->mem[2].addr = gdev->ddr_paddr;
+			p->mem[2].size = extram_pool_sz;
+			p->mem[2].memtype = UIO_MEM_PHYS;
+		} else {
+			p->mem[1].addr = gdev->ddr_paddr;
+			p->mem[1].size = extram_pool_sz;
+			p->mem[1].memtype = UIO_MEM_PHYS;
+		}
 
 		p->name = kasprintf(GFP_KERNEL, "pruss_evt%d", cnt);
 		p->version = DRV_VERSION;
@@ -227,11 +271,19 @@ static int pruss_remove(struct platform_device *dev)
 	return 0;
 }
 
+static const struct of_device_id pruss_dt_ids[] = {
+	{ .compatible = "ti,pruss-v1", .data = NULL, },
+	{ .compatible = "ti,pruss-v2", .data = NULL, },
+	{},
+};
+MODULE_DEVICE_TABLE(of, pruss_dt_ids);
+
 static struct platform_driver pruss_driver = {
 	.probe = pruss_probe,
 	.remove = pruss_remove,
 	.driver = {
 		   .name = DRV_NAME,
+		   .of_match_table = pruss_dt_ids,
 		   },
 };
 
-- 
2.1.4

