From: Sven Wegener <sven.wegener@stealer.net>
Date: Tue Jul 22 10:26:06 2014 +0200
Subject: x86_32, entry: Store badsys error code in %eax
References: bnc#883724, CVE-2014-4508
Git-commit: 8142b215501f8b291a108a202b3a053a265b03dd
Patch-mainline: v3.16-rc7
Signed-off-by: Tony Jones <tonyj@suse.de>

    x86_32, entry: Store badsys error code in %eax
    
    Commit 554086d ("x86_32, entry: Do syscall exit work on badsys
    (CVE-2014-4508)") introduced a regression in the x86_32 syscall entry
    code, resulting in syscall() not returning proper errors for undefined
    syscalls on CPUs supporting the sysenter feature.
    
    The following code:
    
    > int result = syscall(666);
    > printf("result=%d errno=%d error=%s\n", result, errno, strerror(errno));
    
    results in:
    
    > result=666 errno=0 error=Success
    
    Obviously, the syscall return value is the called syscall number, but it
    should have been an ENOSYS error. When run under ptrace it behaves
    correctly, which makes it hard to debug in the wild:
    
    > result=-1 errno=38 error=Function not implemented
    
    The %eax register is the return value register. For debugging via ptrace
    the syscall entry code stores the complete register context on the
    stack. The badsys handlers only store the ENOSYS error code in the
    ptrace register set and do not set %eax like a regular syscall handler
    would. The old resume_userspace call chain contains code that clobbers
    %eax and it restores %eax from the ptrace registers afterwards. The same
    goes for the ptrace-enabled call chain. When ptrace is not used, the
    syscall return value is the passed-in syscall number from the untouched
    %eax register.
    
    Use %eax as the return value register in syscall_badsys and
    sysenter_badsys, like a real syscall handler does, and have the caller
    push the value onto the stack for ptrace access.
    
    Signed-off-by: Sven Wegener <sven.wegener@stealer.net>
    Link: http://lkml.kernel.org/r/alpine.LNX.2.11.1407221022380.31021@titan.int.lan.stealer.net
    Reviewed-and-tested-by: Andy Lutomirski <luto@amacapital.net>
    Cc: <stable@vger.kernel.org> # If 554086d is backported
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>

Automatically created from "patches.fixes/audit_x86_32-entry-store-badsys-error-code-in-eax-cve-2014-4508.patch" by xen-port-patches.py

--- 12.3.orig/arch/x86/kernel/entry_32-xen.S	2014-07-03 11:52:42.000000000 +0200
+++ 12.3/arch/x86/kernel/entry_32-xen.S	2014-07-29 11:21:59.000000000 +0200
@@ -440,8 +440,8 @@ sysenter_do_call:
 	cmpl $(NR_syscalls), %eax
 	jae sysenter_badsys
 	call *sys_call_table(,%eax,4)
-	movl %eax,PT_EAX(%esp)
 sysenter_after_call:
+	movl %eax,PT_EAX(%esp)
 	LOCKDEP_SYS_EXIT
 	DISABLE_INTERRUPTS(CLBR_ANY)
 	TRACE_IRQS_OFF
@@ -543,6 +543,7 @@ ENTRY(system_call)
 	jae syscall_badsys
 syscall_call:
 	call *sys_call_table(,%eax,4)
+syscall_after_call:
 	movl %eax,PT_EAX(%esp)		# store the return value
 syscall_exit:
 	LOCKDEP_SYS_EXIT
@@ -754,12 +755,12 @@ syscall_fault:
 END(syscall_fault)
 
 syscall_badsys:
-	movl $-ENOSYS,PT_EAX(%esp)
-	jmp syscall_exit
+	movl $-ENOSYS,%eax
+	jmp syscall_after_call
 END(syscall_badsys)
 
 sysenter_badsys:
-	movl $-ENOSYS,PT_EAX(%esp)
+	movl $-ENOSYS,%eax
 	jmp sysenter_after_call
 END(sysenter_badsys)
 	CFI_ENDPROC
@@ -1480,6 +1481,7 @@ ENTRY(ia32pv_cstar_target)
 	btl %eax,cstar_special
 	jc .Lcstar_special
 	call *cstar_call_table(,%eax,4)
+.Lcstar_after_call:
 	movl %eax,PT_EAX(%esp)		# store the return value
 .Lcstar_exit:
 	movl PT_ECX(%esp),%ecx
@@ -1495,10 +1497,9 @@ GLOBAL(cstar_set_tif)
 	orl $_TIF_CSTAR,TI_flags(%ebp)
 	jmp *sys_call_table(,%eax,4)
 cstar_clear_tif:
-	movl %eax,PT_EAX(%esp)		# store the return value
 	LOCK_PREFIX
 	andl $~_TIF_CSTAR,TI_flags(%ebp)
-	jmp .Lcstar_exit
+	jmp .Lcstar_after_call
 cstar_trace_entry:
 	movl $-ENOSYS,PT_EAX(%esp)
 	cmpl $NR_syscalls,%eax
@@ -1525,8 +1526,8 @@ cstar_trace_entry:
 	jb syscall_call
 	jmp syscall_exit
 cstar_badsys:
-	movl $-ENOSYS,PT_EAX(%esp)
-	jmp .Lcstar_exit
+	movl $-ENOSYS,%eax
+	jmp .Lcstar_after_call
 	CFI_RESTORE_STATE
 cstar_fault:
 	movl $-EFAULT,%eax
