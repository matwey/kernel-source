From: Linux Kernel Mailing List <linux-kernel@vger.kernel.org>
Subject: Linux: 3.7
Patch-mainline: 3.7

 This patch contains the differences between 3.6 and 3.7.

Automatically created from "patch-3.7" by xen-port-patches.py
Acked-by: jbeulich@suse.com

--- 12.3.orig/arch/arm/Kconfig	2013-11-27 11:08:55.000000000 +0100
+++ 12.3/arch/arm/Kconfig	2012-12-06 16:18:50.000000000 +0100
@@ -1845,9 +1845,9 @@ config CC_STACKPROTECTOR
 
 config XEN_DOM0
 	def_bool y
-	depends on XEN
+	depends on PARAVIRT_XEN
 
-config XEN
+config PARAVIRT_XEN
 	bool "Xen guest support on ARM (EXPERIMENTAL)"
 	depends on EXPERIMENTAL && ARM && OF
 	depends on CPU_V7 && !CPU_V6
--- 12.3.orig/arch/arm/Makefile	2013-11-27 11:08:55.000000000 +0100
+++ 12.3/arch/arm/Makefile	2012-10-30 15:36:13.000000000 +0100
@@ -251,7 +251,7 @@ endif
 core-$(CONFIG_FPE_NWFPE)	+= arch/arm/nwfpe/
 core-$(CONFIG_FPE_FASTFPE)	+= $(FASTFPE_OBJ)
 core-$(CONFIG_VFP)		+= arch/arm/vfp/
-core-$(CONFIG_XEN)		+= arch/arm/xen/
+core-$(CONFIG_PARAVIRT_XEN)	+= arch/arm/xen/
 
 # If we have a machine-specific directory, then include it in the build.
 core-y				+= arch/arm/kernel/ arch/arm/mm/ arch/arm/common/
--- 12.3.orig/arch/arm/include/asm/xen/interface.h	2013-11-27 11:08:55.000000000 +0100
+++ 12.3/arch/arm/include/asm/xen/interface.h	2012-10-31 11:29:25.000000000 +0100
@@ -11,14 +11,14 @@
 
 #define uint64_aligned_t uint64_t __attribute__((aligned(8)))
 
-#define __DEFINE_GUEST_HANDLE(name, type) \
+#define __DEFINE_XEN_GUEST_HANDLE(name, type) \
 	typedef struct { union { type *p; uint64_aligned_t q; }; }  \
         __guest_handle_ ## name
 
 #define DEFINE_GUEST_HANDLE_STRUCT(name) \
-	__DEFINE_GUEST_HANDLE(name, struct name)
-#define DEFINE_GUEST_HANDLE(name) __DEFINE_GUEST_HANDLE(name, name)
-#define GUEST_HANDLE(name)        __guest_handle_ ## name
+	__DEFINE_XEN_GUEST_HANDLE(name, struct name)
+#define DEFINE_XEN_GUEST_HANDLE(name) __DEFINE_XEN_GUEST_HANDLE(name, name)
+#define XEN_GUEST_HANDLE(name)        __guest_handle_ ## name
 
 #define set_xen_guest_handle(hnd, val)			\
 	do {						\
@@ -40,15 +40,6 @@ typedef uint64_t xen_pfn_t;
 #define PRI_xen_pfn "llx"
 typedef uint64_t xen_ulong_t;
 #define PRI_xen_ulong "llx"
-/* Guest handles for primitive C types. */
-__DEFINE_GUEST_HANDLE(uchar, unsigned char);
-__DEFINE_GUEST_HANDLE(uint,  unsigned int);
-DEFINE_GUEST_HANDLE(char);
-DEFINE_GUEST_HANDLE(int);
-DEFINE_GUEST_HANDLE(void);
-DEFINE_GUEST_HANDLE(uint64_t);
-DEFINE_GUEST_HANDLE(uint32_t);
-DEFINE_GUEST_HANDLE(xen_pfn_t);
 
 /* Maximum number of virtual CPUs in multi-processor guests. */
 #define MAX_VIRT_CPUS 1
--- 12.3.orig/arch/x86/Kconfig	2012-10-23 16:01:05.000000000 +0200
+++ 12.3/arch/x86/Kconfig	2013-04-16 14:09:27.000000000 +0200
@@ -88,7 +88,7 @@ config X86
 	select IRQ_FORCED_THREADING
 	select USE_GENERIC_SMP_HELPERS if SMP
 	select HAVE_BPF_JIT if X86_64
-	select HAVE_ARCH_TRANSPARENT_HUGEPAGE
+	select HAVE_ARCH_TRANSPARENT_HUGEPAGE if !XEN
 	select CLKEVT_I8253 if !XEN
 	select ARCH_HAVE_NMI_SAFE_CMPXCHG
 	select GENERIC_IOMAP
@@ -1537,6 +1537,7 @@ config ARCH_RANDOM
 config X86_SMAP
 	def_bool y
 	prompt "Supervisor Mode Access Prevention" if EXPERT
+	depends on !XEN
 	---help---
 	  Supervisor Mode Access Prevention (SMAP) is a security
 	  feature in newer Intel processors.  There is a small
--- 12.3.orig/arch/x86/ia32/ia32entry-xen.S	2012-06-14 11:23:26.000000000 +0200
+++ 12.3/arch/x86/ia32/ia32entry-xen.S	2012-10-29 17:13:41.000000000 +0100
@@ -14,6 +14,7 @@
 #include <asm/segment.h>
 #include <asm/irqflags.h>
 #include <asm/asm.h>
+#include <asm/smap.h>
 #include <linux/linkage.h>
 #include <linux/err.h>
 
@@ -138,8 +139,10 @@ ENTRY(ia32_sysenter_target)
 	SAVE_ARGS 0,1,0
  	/* no need to do an access_ok check here because rbp has been
  	   32bit zero extended */ 
+	ASM_STAC
 1:	movl	(%rbp),%ebp
 	_ASM_EXTABLE(1b,ia32_badarg)
+	ASM_CLAC
 	orl     $TS_COMPAT,TI_status+THREAD_INFO(%rsp,RIP-ARGOFFSET)
 	testl   $_TIF_WORK_SYSCALL_ENTRY,TI_flags+THREAD_INFO(%rsp,RIP-ARGOFFSET)
 	jnz  sysenter_tracesys
@@ -212,8 +215,10 @@ ENTRY(ia32_cstar_target)
 	/* no need to do an access_ok check here because r8 has been
 	   32bit zero extended */ 
 	/* hardware stack frame is complete now */	
+	ASM_STAC
 1:	movl	(%r8),%r9d
 	_ASM_EXTABLE(1b,ia32_badarg)
+	ASM_CLAC
 	orl     $TS_COMPAT,TI_status+THREAD_INFO(%rsp,RIP-ARGOFFSET)
 	testl   $_TIF_WORK_SYSCALL_ENTRY,TI_flags+THREAD_INFO(%rsp,RIP-ARGOFFSET)
 	jnz   cstar_tracesys
@@ -250,6 +255,7 @@ cstar_tracesys:
 END(ia32_cstar_target)
 				
 ia32_badarg:
+	ASM_CLAC
 	movq $-EFAULT,%rax
 	jmp ia32_sysret
 	CFI_ENDPROC
@@ -349,7 +355,7 @@ GLOBAL(\label)
 	PTREGSCALL stub32_rt_sigreturn, sys32_rt_sigreturn, %rdi
 	PTREGSCALL stub32_sigreturn, sys32_sigreturn, %rdi
 	PTREGSCALL stub32_sigaltstack, sys32_sigaltstack, %rdx
-	PTREGSCALL stub32_execve, sys32_execve, %rcx
+	PTREGSCALL stub32_execve, compat_sys_execve, %rcx
 	PTREGSCALL stub32_fork, sys_fork, %rdi
 	PTREGSCALL stub32_clone, sys32_clone, %rdx
 	PTREGSCALL stub32_vfork, sys_vfork, %rdi
--- 12.3.orig/arch/x86/include/mach-xen/asm/cmpxchg_32.h	2011-12-23 11:19:52.000000000 +0100
+++ 12.3/arch/x86/include/mach-xen/asm/cmpxchg_32.h	2012-10-31 16:05:25.000000000 +0100
@@ -1,6 +1,8 @@
 #ifndef _ASM_X86_XEN_CMPXCHG_32_H
 #define _ASM_X86_XEN_CMPXCHG_32_H
 
+#include_next <asm/cmpxchg_32.h>
+
 static inline u64 get_64bit(const volatile u64 *ptr)
 {
 	u64 res;
--- 12.3.orig/arch/x86/include/mach-xen/asm/cmpxchg_64.h	2011-12-23 11:21:03.000000000 +0100
+++ 12.3/arch/x86/include/mach-xen/asm/cmpxchg_64.h	2012-10-31 16:05:32.000000000 +0100
@@ -1,6 +1,8 @@
 #ifndef _ASM_X86_XEN_CMPXCHG_64_H
 #define _ASM_X86_XEN_CMPXCHG_64_H
 
+#include_next <asm/cmpxchg_64.h>
+
 static inline u64 get_64bit(const volatile u64 *ptr)
 {
 	return *ptr;
--- 12.3.orig/arch/x86/include/mach-xen/asm/fpu-internal.h	2012-10-29 15:23:05.000000000 +0100
+++ 12.3/arch/x86/include/mach-xen/asm/fpu-internal.h	2012-11-15 14:56:34.000000000 +0100
@@ -4,14 +4,19 @@
 #include_next <asm/fpu-internal.h>
 #undef switch_fpu_prepare
 
-static inline void xen_thread_fpu_begin(struct task_struct *tsk,
+static inline bool xen_thread_fpu_begin(struct task_struct *tsk,
 					multicall_entry_t *mcl)
 {
-	if (mcl) {
+	bool ret = false;
+
+	if (mcl && !use_eager_fpu()) {
 		mcl->op = __HYPERVISOR_fpu_taskswitch;
 		mcl->args[0] = 0;
+		ret = true;
 	}
 	__thread_set_has_fpu(tsk);
+
+	return ret;
 }
 
 static inline fpu_switch_t xen_switch_fpu_prepare(struct task_struct *old,
@@ -21,7 +26,12 @@ static inline fpu_switch_t xen_switch_fp
 {
 	fpu_switch_t fpu;
 
-	fpu.preload = tsk_used_math(new) && new->fpu_counter > 5;
+	/*
+	 * If the task has used the math, pre-load the FPU on xsave processors
+	 * or if the past 5 consecutive context-switches used math.
+	 */
+	fpu.preload = tsk_used_math(new) && (use_eager_fpu() ||
+					     new->fpu_counter > 5);
 	if (__thread_has_fpu(old)) {
 		if (!__save_init_fpu(old))
 			cpu = ~0;
@@ -33,7 +43,7 @@ static inline fpu_switch_t xen_switch_fp
 			new->fpu_counter++;
 			__thread_set_has_fpu(new);
 			prefetch(new->thread.fpu.state);
-		} else {
+		} else if (!use_eager_fpu()) {
 			(*mcl)->op = __HYPERVISOR_fpu_taskswitch;
 			(*mcl)++->args[0] = 1;
 		}
@@ -42,11 +52,12 @@ static inline fpu_switch_t xen_switch_fp
 		old->thread.fpu.last_cpu = ~0;
 		if (fpu.preload) {
 			new->fpu_counter++;
-			if (fpu_lazy_restore(new, cpu))
+			if (!use_eager_fpu() && fpu_lazy_restore(new, cpu))
 				fpu.preload = 0;
 			else
 				prefetch(new->thread.fpu.state);
-			xen_thread_fpu_begin(new, (*mcl)++);
+			if (xen_thread_fpu_begin(new, *mcl))
+				++*mcl;
 		}
 	}
 	return fpu;
--- 12.3.orig/arch/x86/include/mach-xen/asm/perf_event.h	2011-09-08 16:54:08.000000000 +0200
+++ 12.3/arch/x86/include/mach-xen/asm/perf_event.h	2012-10-29 17:13:41.000000000 +0100
@@ -39,4 +39,6 @@
 
 #endif
 
+#define arch_perf_out_copy_user copy_from_user_nmi
+
 #endif /* _ASM_X86_PERF_EVENT_H */
--- 12.3.orig/arch/x86/include/mach-xen/asm/pgtable.h	2012-06-18 09:47:52.000000000 +0200
+++ 12.3/arch/x86/include/mach-xen/asm/pgtable.h	2012-10-29 17:13:41.000000000 +0100
@@ -140,8 +140,7 @@ static inline unsigned long pmd_pfn(pmd_
 
 static inline int pmd_large(pmd_t pte)
 {
-	return (pmd_flags(pte) & (_PAGE_PSE | _PAGE_PRESENT)) ==
-		(_PAGE_PSE | _PAGE_PRESENT);
+	return pmd_flags(pte) & _PAGE_PSE;
 }
 
 #ifdef CONFIG_TRANSPARENT_HUGEPAGE
@@ -382,9 +381,9 @@ pte_t *populate_extra_pte(unsigned long 
 #endif	/* __ASSEMBLY__ */
 
 #ifdef CONFIG_X86_32
-# include "pgtable_32.h"
+# include <asm/pgtable_32.h>
 #else
-# include "pgtable_64.h"
+# include <asm/pgtable_64.h>
 #endif
 
 #ifndef __ASSEMBLY__
@@ -418,7 +417,13 @@ static inline int pmd_present(pmd_t pmd)
    can temporarily clear it. */
 	return __pmd_val(pmd) != 0;
 #else
-	return pmd_flags(pmd) & _PAGE_PRESENT;
+	/*
+	 * Checking for _PAGE_PSE is needed too because
+	 * split_huge_page will temporarily clear the present bit (but
+	 * the _PAGE_PSE flag will remain set at all times while the
+	 * _PAGE_PRESENT bit is clear).
+	 */
+	return pmd_flags(pmd) & (_PAGE_PRESENT | _PAGE_PROTNONE | _PAGE_PSE);
 #endif
 }
 
--- 12.3.orig/arch/x86/include/mach-xen/asm/pgtable_32.h	2011-02-01 15:09:47.000000000 +0100
+++ 12.3/arch/x86/include/mach-xen/asm/pgtable_32.h	2012-10-29 17:13:41.000000000 +0100
@@ -70,6 +70,7 @@ do {									\
  * tables contain all the necessary information.
  */
 #define update_mmu_cache(vma, address, ptep) do { } while (0)
+#define update_mmu_cache_pmd(vma, address, pmd) do { } while (0)
 
 void make_lowmem_page_readonly(void *va, unsigned int feature);
 void make_lowmem_page_writable(void *va, unsigned int feature);
--- 12.3.orig/arch/x86/include/mach-xen/asm/pgtable_64.h	2012-08-20 14:37:06.000000000 +0200
+++ 12.3/arch/x86/include/mach-xen/asm/pgtable_64.h	2012-10-29 17:13:41.000000000 +0100
@@ -143,6 +143,7 @@ static inline int pgd_large(pgd_t pgd) {
 #define pte_unmap(pte) ((void)(pte))/* NOP */
 
 #define update_mmu_cache(vma, address, ptep) do { } while (0)
+#define update_mmu_cache_pmd(vma, address, pmd) do { } while (0)
 
 /* Encode and de-code a swap entry */
 #if _PAGE_BIT_FILE < _PAGE_BIT_PROTNONE
--- 12.3.orig/arch/x86/include/mach-xen/asm/pgtable_types.h	2011-09-08 16:54:08.000000000 +0200
+++ 12.3/arch/x86/include/mach-xen/asm/pgtable_types.h	2012-10-29 17:13:41.000000000 +0100
@@ -190,7 +190,7 @@ extern unsigned int __kernel_page_user;
 #ifdef CONFIG_X86_32
 # include <asm/pgtable_32_types.h>
 #else
-# include "pgtable_64_types.h"
+# include <asm/pgtable_64_types.h>
 #endif
 
 #ifndef __ASSEMBLY__
@@ -361,6 +361,7 @@ int phys_mem_access_prot_allowed(struct 
 void set_pte_vaddr(unsigned long vaddr, pte_t pte);
 
 extern void xen_pagetable_reserve(u64 start, u64 end);
+#define xen_pagetable_init        paging_init
 
 struct seq_file;
 extern void arch_report_meminfo(struct seq_file *m);
--- 12.3.orig/arch/x86/include/mach-xen/asm/processor.h	2012-08-20 14:37:06.000000000 +0200
+++ 12.3/arch/x86/include/mach-xen/asm/processor.h	2012-10-29 17:13:41.000000000 +0100
@@ -443,7 +443,6 @@ DECLARE_INIT_PER_CPU(irq_stack_union);
 
 DECLARE_PER_CPU(char *, irq_stack_ptr);
 DECLARE_PER_CPU(unsigned int, irq_count);
-extern unsigned long kernel_eflags;
 extern asmlinkage void ignore_sysret(void);
 #else	/* X86_64 */
 #ifdef CONFIG_CC_STACKPROTECTOR
@@ -590,11 +589,6 @@ typedef struct {
 } mm_segment_t;
 
 
-/*
- * create a kernel thread without removing it from tasklists
- */
-extern int kernel_thread(int (*fn)(void *), void *arg, unsigned long flags);
-
 /* Free all resources held by a thread. */
 extern void release_thread(struct task_struct *);
 
@@ -760,6 +754,8 @@ static inline void update_debugctlmsr(un
 	wrmsrl(MSR_IA32_DEBUGCTLMSR, debugctlmsr);
 }
 
+extern void set_task_blockstep(struct task_struct *task, bool on);
+
 /*
  * from system description table in BIOS. Mostly for MCA use, but
  * others may find it useful:
--- 12.3.orig/arch/x86/kernel/acpi/processor_extcntl_xen.c	2012-04-11 15:22:55.000000000 +0200
+++ 12.3/arch/x86/kernel/acpi/processor_extcntl_xen.c	2012-10-31 08:25:00.000000000 +0100
@@ -59,7 +59,7 @@ static int xen_cx_notifier(struct acpi_p
 
 		data->type = cx->type;
 		data->latency = cx->latency;
-		data->power = cx->power;
+		/* data->power = cx->power; */
 		data->reg.space_id = cx->reg.space_id;
 		data->reg.bit_width = cx->reg.bit_width;
 		data->reg.bit_offset = cx->reg.bit_offset;
--- 12.3.orig/arch/x86/kernel/apic/io_apic-xen.c	2012-09-05 15:48:34.000000000 +0200
+++ 12.3/arch/x86/kernel/apic/io_apic-xen.c	2012-10-31 11:57:31.000000000 +0100
@@ -2336,6 +2336,9 @@ asmlinkage void smp_irq_move_cleanup_int
 			continue;
 
 		cfg = irq_cfg(irq);
+		if (!cfg)
+			continue;
+
 		raw_spin_lock(&desc->lock);
 
 		/*
--- 12.3.orig/arch/x86/kernel/cpu/amd.c	2012-12-06 16:17:59.000000000 +0100
+++ 12.3/arch/x86/kernel/cpu/amd.c	2012-12-06 16:55:03.000000000 +0100
@@ -641,7 +641,6 @@ static void __cpuinit init_amd(struct cp
 			}
 		}
 	}
-#endif
 
 	/*
 	 * The way access filter has a performance penalty on some workloads.
@@ -656,6 +655,7 @@ static void __cpuinit init_amd(struct cp
 			wrmsrl_safe(0xc0011021, val);
 		}
 	}
+#endif
 
 	cpu_detect_cache_sizes(c);
 
--- 12.3.orig/arch/x86/kernel/cpu/common-xen.c	2012-09-05 15:48:34.000000000 +0200
+++ 12.3/arch/x86/kernel/cpu/common-xen.c	2012-10-29 17:13:41.000000000 +0100
@@ -279,23 +279,36 @@ static inline void squash_the_stupid_ser
 }
 #endif
 
-static int disable_smep __cpuinitdata;
 static __init int setup_disable_smep(char *arg)
 {
-	disable_smep = 1;
+	setup_clear_cpu_cap(X86_FEATURE_SMEP);
 	return 1;
 }
 __setup("nosmep", setup_disable_smep);
 
-static __cpuinit void setup_smep(struct cpuinfo_x86 *c)
+static __always_inline void setup_smep(struct cpuinfo_x86 *c)
 {
-	if (cpu_has(c, X86_FEATURE_SMEP)) {
-		if (unlikely(disable_smep)) {
-			setup_clear_cpu_cap(X86_FEATURE_SMEP);
-			clear_in_cr4(X86_CR4_SMEP);
-		} else
-			set_in_cr4(X86_CR4_SMEP);
-	}
+	if (cpu_has(c, X86_FEATURE_SMEP))
+		set_in_cr4(X86_CR4_SMEP);
+}
+
+static __init int setup_disable_smap(char *arg)
+{
+	setup_clear_cpu_cap(X86_FEATURE_SMAP);
+	return 1;
+}
+__setup("nosmap", setup_disable_smap);
+
+static __always_inline void setup_smap(struct cpuinfo_x86 *c)
+{
+	unsigned long eflags;
+
+	/* This should have been cleared long ago */
+	raw_local_save_flags(eflags);
+	BUG_ON(eflags & X86_EFLAGS_AC);
+
+	if (cpu_has(c, X86_FEATURE_SMAP))
+		set_in_cr4(X86_CR4_SMAP);
 }
 
 /*
@@ -518,7 +531,7 @@ void __cpuinit cpu_detect_tlb(struct cpu
 
 	printk(KERN_INFO "Last level iTLB entries: 4KB %d, 2MB %d, 4MB %d\n" \
 		"Last level dTLB entries: 4KB %d, 2MB %d, 4MB %d\n"	     \
-		"tlb_flushall_shift is 0x%x\n",
+		"tlb_flushall_shift: %d\n",
 		tlb_lli_4k[ENTRIES], tlb_lli_2m[ENTRIES],
 		tlb_lli_4m[ENTRIES], tlb_lld_4k[ENTRIES],
 		tlb_lld_2m[ENTRIES], tlb_lld_4m[ENTRIES],
@@ -761,8 +774,6 @@ static void __init early_identify_cpu(st
 	c->cpu_index = 0;
 	filter_cpuid_features(c, false);
 
-	setup_smep(c);
-
 	if (this_cpu->c_bsp_init)
 		this_cpu->c_bsp_init(c);
 }
@@ -849,8 +860,6 @@ static void __cpuinit generic_identify(s
 	}
 #endif
 
-	setup_smep(c);
-
 	get_model_name(c); /* Default name */
 
 	detect_nopl(c);
@@ -919,6 +928,10 @@ static void __cpuinit identify_cpu(struc
 	/* Disable the PN if appropriate */
 	squash_the_stupid_serial_number(c);
 
+	/* Set up SMEP/SMAP */
+	setup_smep(c);
+	setup_smap(c);
+
 	/*
 	 * The vendor-specific functions might have changed features.
 	 * Now we do "generic changes."
@@ -997,8 +1010,7 @@ void __init identify_boot_cpu(void)
 #else
 	vgetcpu_set_mode();
 #endif
-	if (boot_cpu_data.cpuid_level >= 2)
-		cpu_detect_tlb(&boot_cpu_data);
+	cpu_detect_tlb(&boot_cpu_data);
 }
 
 #ifdef CONFIG_XEN
@@ -1082,14 +1094,16 @@ void __cpuinit print_cpu_info(struct cpu
 		printk(KERN_CONT "%s ", vendor);
 
 	if (c->x86_model_id[0])
-		printk(KERN_CONT "%s", c->x86_model_id);
+		printk(KERN_CONT "%s", strim(c->x86_model_id));
 	else
 		printk(KERN_CONT "%d86", c->x86);
 
+	printk(KERN_CONT " (fam: %02x, model: %02x", c->x86, c->x86_model);
+
 	if (c->x86_mask || c->cpuid_level >= 0)
-		printk(KERN_CONT " stepping %02x\n", c->x86_mask);
+		printk(KERN_CONT ", stepping: %02x)\n", c->x86_mask);
 	else
-		printk(KERN_CONT "\n");
+		printk(KERN_CONT ")\n");
 
 	print_cpu_msr(c);
 }
@@ -1197,12 +1211,11 @@ void __cpuinit syscall_init(void)
 #ifndef CONFIG_XEN
 	/* Flags to clear on syscall */
 	wrmsrl(MSR_SYSCALL_MASK,
-	       X86_EFLAGS_TF|X86_EFLAGS_DF|X86_EFLAGS_IF|X86_EFLAGS_IOPL);
+	       X86_EFLAGS_TF|X86_EFLAGS_DF|X86_EFLAGS_IF|
+	       X86_EFLAGS_IOPL|X86_EFLAGS_AC);
 #endif
 }
 
-unsigned long kernel_eflags;
-
 #ifndef CONFIG_X86_NO_TSS
 /*
  * Copies of the original ist values from the tss are only accessed during
@@ -1403,15 +1416,6 @@ void __cpuinit cpu_init(void)
 	dbg_restore_debug_regs();
 
 	fpu_init();
-	xsave_init();
-
-#ifndef CONFIG_XEN
-	raw_local_save_flags(kernel_eflags);
-#else
-	asm ("pushfq; popq %0" : "=rm" (kernel_eflags));
-	if (raw_irqs_disabled())
-		kernel_eflags &= ~X86_EFLAGS_IF;
-#endif
 
 #ifdef CONFIG_X86_LOCAL_APIC
 	if (is_uv_system())
@@ -1468,6 +1472,5 @@ void __cpuinit cpu_init(void)
 	dbg_restore_debug_regs();
 
 	fpu_init();
-	xsave_init();
 }
 #endif
--- 12.3.orig/arch/x86/kernel/e820-xen.c	2012-08-20 14:37:06.000000000 +0200
+++ 12.3/arch/x86/kernel/e820-xen.c	2012-10-31 11:57:31.000000000 +0100
@@ -1212,6 +1212,9 @@ void __init memblock_x86_fill(void)
 				 PFN_PHYS(max_pfn - xen_start_info->nr_pages));
 #endif
 
+	/* throw away partial pages */
+	memblock_trim_memory(PAGE_SIZE);
+
 	memblock_dump_all();
 }
 
--- 12.3.orig/arch/x86/kernel/entry_32-xen.S	2013-01-25 14:16:28.000000000 +0100
+++ 12.3/arch/x86/kernel/entry_32-xen.S	2013-01-25 14:17:05.000000000 +0100
@@ -57,6 +57,7 @@
 #include <asm/cpufeature.h>
 #include <asm/alternative-asm.h>
 #include <asm/asm.h>
+#include <asm/smap.h>
 #include <xen/interface/xen.h>
 
 /* Avoid __ASSEMBLER__'ifying <linux/audit.h> just for this.  */
@@ -302,6 +303,21 @@ ENTRY(ret_from_fork)
 	CFI_ENDPROC
 END(ret_from_fork)
 
+ENTRY(ret_from_kernel_thread)
+	CFI_STARTPROC
+	pushl_cfi %eax
+	call schedule_tail
+	GET_THREAD_INFO(%ebp)
+	popl_cfi %eax
+	pushl_cfi $0x0202		# Reset kernel eflags
+	popfl_cfi
+	movl PT_EBP(%esp),%eax
+	call *PT_EBX(%esp)
+	movl $0,PT_EAX(%esp)
+	jmp syscall_exit
+	CFI_ENDPROC
+ENDPROC(ret_from_kernel_thread)
+
 /*
  * Interrupt exit functions should be protected against kprobes
  */
@@ -326,8 +342,7 @@ ret_from_intr:
 	andl $(X86_EFLAGS_VM | SEGMENT_RPL_MASK), %eax
 #else
 	/*
-	 * We can be coming here from a syscall done in the kernel space,
-	 * e.g. a failed kernel_execve().
+	 * We can be coming here from child spawned by kernel_thread().
 	 */
 	movl PT_CS(%esp), %eax
 	andl $SEGMENT_RPL_MASK, %eax
@@ -411,7 +426,9 @@ sysenter_past_esp:
  */
 	cmpl $__PAGE_OFFSET-3,%ebp
 	jae syscall_fault
+	ASM_STAC
 1:	movl (%ebp),%ebp
+	ASM_CLAC
 	movl %ebp,PT_EBP(%esp)
 	_ASM_EXTABLE(1b,syscall_fault)
 
@@ -514,6 +531,7 @@ ENDPROC(ia32pv_sysenter_target)
 	# system call handler stub
 ENTRY(system_call)
 	RING0_INT_FRAME			# can't unwind into user space anyway
+	ASM_CLAC
 	pushl_cfi %eax			# save orig_eax
 	SAVE_ALL
 	GET_THREAD_INFO(%ebp)
@@ -675,6 +693,10 @@ work_notifysig:				# deal with pending s
 	movl %esp, %eax
 	jne work_notifysig_v86		# returning to kernel-space or
 					# vm86-space
+1:
+#else
+	movl %esp, %eax
+#endif
 	TRACE_IRQS_ON
 	ENABLE_INTERRUPTS(CLBR_NONE)
 	movb PT_CS(%esp), %bl
@@ -685,24 +707,15 @@ work_notifysig:				# deal with pending s
 	call do_notify_resume
 	jmp resume_userspace
 
+#ifdef CONFIG_VM86
 	ALIGN
 work_notifysig_v86:
 	pushl_cfi %ecx			# save ti_flags for do_notify_resume
 	call save_v86_state		# %eax contains pt_regs pointer
 	popl_cfi %ecx
 	movl %eax, %esp
-#else
-	movl %esp, %eax
+	jmp 1b
 #endif
-	TRACE_IRQS_ON
-	ENABLE_INTERRUPTS(CLBR_NONE)
-	movb PT_CS(%esp), %bl
-	andb $SEGMENT_RPL_MASK, %bl
-	cmpb $USER_RPL, %bl
-	jb resume_kernel
-	xorl %edx, %edx
-	call do_notify_resume
-	jmp resume_userspace
 END(work_pending)
 
 	# perform syscall exit tracing
@@ -733,6 +746,7 @@ END(syscall_exit_work)
 
 	RING0_INT_FRAME			# can't unwind into user space anyway
 syscall_fault:
+	ASM_CLAC
 	GET_THREAD_INFO(%ebp)
 	movl $-EFAULT,PT_EAX(%esp)
 	jmp resume_userspace
@@ -790,7 +804,6 @@ ENDPROC(ptregs_##name)
 PTREGSCALL1(iopl)
 PTREGSCALL0(fork)
 PTREGSCALL0(vfork)
-PTREGSCALL3(execve)
 PTREGSCALL2(sigaltstack)
 PTREGSCALL0(sigreturn)
 PTREGSCALL0(rt_sigreturn)
@@ -889,6 +902,7 @@ END(interrupt)
  */
 	.p2align CONFIG_X86_L1_CACHE_SHIFT
 common_interrupt:
+	ASM_CLAC
 	addl $-0x80,(%esp)	/* Adjust vector into the [-256,-1] range */
 	SAVE_ALL
 	TRACE_IRQS_OFF
@@ -905,6 +919,7 @@ ENDPROC(common_interrupt)
 #define BUILD_INTERRUPT3(name, nr, fn)	\
 ENTRY(name)				\
 	RING0_INT_FRAME;		\
+	ASM_CLAC;			\
 	pushl_cfi $~(nr);		\
 	SAVE_ALL;			\
 	TRACE_IRQS_OFF			\
@@ -942,6 +957,7 @@ ENDPROC(name)
 # so we can simply throw away the new one.
 ENTRY(hypervisor_callback)
 	RING0_INT_FRAME
+	ASM_CLAC
 	pushl_cfi $-1
 	SAVE_ALL
 	movl PT_CS(%esp),%ecx
@@ -1025,6 +1041,7 @@ critical_fixup_table:
 # to pop the stack frame we end up in an infinite loop of failsafe callbacks.
 # We distinguish between categories by maintaining a status value in EAX.
 ENTRY(failsafe_callback)
+	ASM_CLAC
 	pushl %eax
 	movl $1,%eax
 1:	mov 4(%esp),%ds
@@ -1062,6 +1079,7 @@ ENTRY(failsafe_callback)
 
 ENTRY(coprocessor_error)
 	RING0_INT_FRAME
+	ASM_CLAC
 	pushl_cfi $0
 	pushl_cfi $do_coprocessor_error
 	jmp error_code
@@ -1070,6 +1088,7 @@ END(coprocessor_error)
 
 ENTRY(simd_coprocessor_error)
 	RING0_INT_FRAME
+	ASM_CLAC
 	pushl_cfi $0
 #ifdef CONFIG_X86_INVD_BUG
 	/* AMD 486 bug: invd from userspace calls exception 19 instead of #GP */
@@ -1091,6 +1110,7 @@ END(simd_coprocessor_error)
 
 ENTRY(device_not_available)
 	RING0_INT_FRAME
+	ASM_CLAC
 	pushl_cfi $-1			# mark this as an int
 	pushl_cfi $do_device_not_available
 	jmp error_code
@@ -1111,6 +1131,7 @@ END(native_irq_enable_sysexit)
 
 ENTRY(overflow)
 	RING0_INT_FRAME
+	ASM_CLAC
 	pushl_cfi $0
 	pushl_cfi $do_overflow
 	jmp error_code
@@ -1119,6 +1140,7 @@ END(overflow)
 
 ENTRY(bounds)
 	RING0_INT_FRAME
+	ASM_CLAC
 	pushl_cfi $0
 	pushl_cfi $do_bounds
 	jmp error_code
@@ -1127,6 +1149,7 @@ END(bounds)
 
 ENTRY(invalid_op)
 	RING0_INT_FRAME
+	ASM_CLAC
 	pushl_cfi $0
 	pushl_cfi $do_invalid_op
 	jmp error_code
@@ -1135,6 +1158,7 @@ END(invalid_op)
 
 ENTRY(coprocessor_segment_overrun)
 	RING0_INT_FRAME
+	ASM_CLAC
 	pushl_cfi $0
 	pushl_cfi $do_coprocessor_segment_overrun
 	jmp error_code
@@ -1143,6 +1167,7 @@ END(coprocessor_segment_overrun)
 
 ENTRY(invalid_TSS)
 	RING0_EC_FRAME
+	ASM_CLAC
 	pushl_cfi $do_invalid_TSS
 	jmp error_code
 	CFI_ENDPROC
@@ -1150,6 +1175,7 @@ END(invalid_TSS)
 
 ENTRY(segment_not_present)
 	RING0_EC_FRAME
+	ASM_CLAC
 	pushl_cfi $do_segment_not_present
 	jmp error_code
 	CFI_ENDPROC
@@ -1157,6 +1183,7 @@ END(segment_not_present)
 
 ENTRY(stack_segment)
 	RING0_EC_FRAME
+	ASM_CLAC
 	pushl_cfi $do_stack_segment
 	jmp error_code
 	CFI_ENDPROC
@@ -1164,6 +1191,7 @@ END(stack_segment)
 
 ENTRY(alignment_check)
 	RING0_EC_FRAME
+	ASM_CLAC
 	pushl_cfi $do_alignment_check
 	jmp error_code
 	CFI_ENDPROC
@@ -1171,6 +1199,7 @@ END(alignment_check)
 
 ENTRY(divide_error)
 	RING0_INT_FRAME
+	ASM_CLAC
 	pushl_cfi $0			# no error code
 	pushl_cfi $do_divide_error
 	jmp error_code
@@ -1180,6 +1209,7 @@ END(divide_error)
 #ifdef CONFIG_X86_MCE
 ENTRY(machine_check)
 	RING0_INT_FRAME
+	ASM_CLAC
 	pushl_cfi $0
 	pushl_cfi machine_check_vector
 	jmp error_code
@@ -1190,6 +1220,7 @@ END(machine_check)
 #ifndef CONFIG_XEN
 ENTRY(spurious_interrupt_bug)
 	RING0_INT_FRAME
+	ASM_CLAC
 	pushl_cfi $0
 	pushl_cfi $do_spurious_interrupt_bug
 	jmp error_code
@@ -1208,16 +1239,6 @@ END(fixup_4gb_segment)
  */
 	.popsection
 
-ENTRY(kernel_thread_helper)
-	pushl $0		# fake return address for unwinder
-	CFI_STARTPROC
-	movl %edi,%eax
-	call *%esi
-	call do_exit
-	ud2			# padding for call trace
-	CFI_ENDPROC
-ENDPROC(kernel_thread_helper)
-
 #ifdef CONFIG_FUNCTION_TRACER
 #ifdef CONFIG_DYNAMIC_FTRACE
 
@@ -1232,17 +1253,21 @@ ENTRY(ftrace_caller)
 	pushl %eax
 	pushl %ecx
 	pushl %edx
-	movl 0xc(%esp), %eax
+	pushl $0	/* Pass NULL as regs pointer */
+	movl 4*4(%esp), %eax
 	movl 0x4(%ebp), %edx
+	leal function_trace_op, %ecx
 	subl $MCOUNT_INSN_SIZE, %eax
 
 .globl ftrace_call
 ftrace_call:
 	call ftrace_stub
 
+	addl $4,%esp	/* skip NULL pointer */
 	popl %edx
 	popl %ecx
 	popl %eax
+ftrace_ret:
 #ifdef CONFIG_FUNCTION_GRAPH_TRACER
 .globl ftrace_graph_call
 ftrace_graph_call:
@@ -1254,6 +1279,71 @@ ftrace_stub:
 	ret
 END(ftrace_caller)
 
+ENTRY(ftrace_regs_caller)
+	pushf	/* push flags before compare (in cs location) */
+	cmpl $0, function_trace_stop
+	jne ftrace_restore_flags
+
+	/*
+	 * i386 does not save SS and ESP when coming from kernel.
+	 * Instead, to get sp, &regs->sp is used (see ptrace.h).
+	 * Unfortunately, that means eflags must be at the same location
+	 * as the current return ip is. We move the return ip into the
+	 * ip location, and move flags into the return ip location.
+	 */
+	pushl 4(%esp)	/* save return ip into ip slot */
+
+	pushl $0	/* Load 0 into orig_ax */
+	pushl %gs
+	pushl %fs
+	pushl %es
+	pushl %ds
+	pushl %eax
+	pushl %ebp
+	pushl %edi
+	pushl %esi
+	pushl %edx
+	pushl %ecx
+	pushl %ebx
+
+	movl 13*4(%esp), %eax	/* Get the saved flags */
+	movl %eax, 14*4(%esp)	/* Move saved flags into regs->flags location */
+				/* clobbering return ip */
+	movl $__KERNEL_CS,13*4(%esp)
+
+	movl 12*4(%esp), %eax	/* Load ip (1st parameter) */
+	subl $MCOUNT_INSN_SIZE, %eax	/* Adjust ip */
+	movl 0x4(%ebp), %edx	/* Load parent ip (2nd parameter) */
+	leal function_trace_op, %ecx /* Save ftrace_pos in 3rd parameter */
+	pushl %esp		/* Save pt_regs as 4th parameter */
+
+GLOBAL(ftrace_regs_call)
+	call ftrace_stub
+
+	addl $4, %esp		/* Skip pt_regs */
+	movl 14*4(%esp), %eax	/* Move flags back into cs */
+	movl %eax, 13*4(%esp)	/* Needed to keep addl from modifying flags */
+	movl 12*4(%esp), %eax	/* Get return ip from regs->ip */
+	movl %eax, 14*4(%esp)	/* Put return ip back for ret */
+
+	popl %ebx
+	popl %ecx
+	popl %edx
+	popl %esi
+	popl %edi
+	popl %ebp
+	popl %eax
+	popl %ds
+	popl %es
+	popl %fs
+	popl %gs
+	addl $8, %esp		/* Skip orig_ax and ip */
+	popf			/* Pop flags at end (no addl to corrupt flags) */
+	jmp ftrace_ret
+
+ftrace_restore_flags:
+	popf
+	jmp  ftrace_stub
 #else /* ! CONFIG_DYNAMIC_FTRACE */
 
 ENTRY(mcount)
@@ -1294,9 +1384,6 @@ END(mcount)
 
 #ifdef CONFIG_FUNCTION_GRAPH_TRACER
 ENTRY(ftrace_graph_caller)
-	cmpl $0, function_trace_stop
-	jne ftrace_stub
-
 	pushl %eax
 	pushl %ecx
 	pushl %edx
@@ -1327,6 +1414,7 @@ return_to_handler:
 	# pv syscall call handler stub
 ENTRY(ia32pv_cstar_target)
 	RING0_INT_FRAME
+	ASM_CLAC
 	movl $__USER_DS,16(%esp)
 	movl %ebp,%ecx
 	movl $__USER_CS,4(%esp)
@@ -1449,6 +1537,7 @@ mask=0
 
 ENTRY(page_fault)
 	RING0_EC_FRAME
+	ASM_CLAC
 	pushl_cfi $do_page_fault
 	ALIGN
 error_code:
@@ -1523,6 +1612,7 @@ END(page_fault)
 
 ENTRY(debug)
 	RING0_INT_FRAME
+	ASM_CLAC
 #ifndef CONFIG_XEN
 	cmpl $ia32_sysenter_target,(%esp)
 	jne debug_stack_correct
@@ -1549,6 +1639,7 @@ END(debug)
  */
 ENTRY(nmi)
 	RING0_INT_FRAME
+	ASM_CLAC
 	pushl_cfi %eax
 #ifndef CONFIG_XEN
 	movl %ss, %eax
@@ -1628,6 +1719,7 @@ END(nmi)
 
 ENTRY(int3)
 	RING0_INT_FRAME
+	ASM_CLAC
 	pushl_cfi $-1			# mark this as an int
 	SAVE_ALL
 	TRACE_IRQS_OFF
@@ -1648,6 +1740,7 @@ END(general_protection)
 #ifdef CONFIG_KVM_GUEST
 ENTRY(async_page_fault)
 	RING0_EC_FRAME
+	ASM_CLAC
 	pushl_cfi $do_async_page_fault
 	jmp error_code
 	CFI_ENDPROC
--- 12.3.orig/arch/x86/kernel/entry_64-xen.S	2012-08-20 14:37:06.000000000 +0200
+++ 12.3/arch/x86/kernel/entry_64-xen.S	2012-10-30 14:02:02.000000000 +0100
@@ -59,6 +59,8 @@
 #include <asm/ftrace.h>
 #include <asm/percpu.h>
 #include <asm/asm.h>
+#include <asm/rcu.h>
+#include <asm/smap.h>
 #include <linux/err.h>
 #include <xen/interface/xen.h>
 #include <xen/interface/features.h>
@@ -73,25 +75,51 @@
 	.section .entry.text, "ax"
 
 #ifdef CONFIG_FUNCTION_TRACER
+
+#ifdef CC_USING_FENTRY
+# define function_hook	__fentry__
+#else
+# define function_hook	mcount
+#endif
+
 #ifdef CONFIG_DYNAMIC_FTRACE
-ENTRY(mcount)
+
+ENTRY(function_hook)
 	retq
-END(mcount)
+END(function_hook)
+
+/* skip is set if stack has been adjusted */
+.macro ftrace_caller_setup skip=0
+	MCOUNT_SAVE_FRAME \skip
+
+	/* Load the ftrace_ops into the 3rd parameter */
+	leaq function_trace_op, %rdx
+
+	/* Load ip into the first parameter */
+	movq RIP(%rsp), %rdi
+	subq $MCOUNT_INSN_SIZE, %rdi
+	/* Load the parent_ip into the second parameter */
+#ifdef CC_USING_FENTRY
+	movq SS+16(%rsp), %rsi
+#else
+	movq 8(%rbp), %rsi
+#endif
+.endm
 
 ENTRY(ftrace_caller)
+	/* Check if tracing was disabled (quick check) */
 	cmpl $0, function_trace_stop
 	jne  ftrace_stub
 
-	MCOUNT_SAVE_FRAME
-
-	movq 0x38(%rsp), %rdi
-	movq 8(%rbp), %rsi
-	subq $MCOUNT_INSN_SIZE, %rdi
+	ftrace_caller_setup
+	/* regs go into 4th parameter (but make it NULL) */
+	movq $0, %rcx
 
 GLOBAL(ftrace_call)
 	call ftrace_stub
 
 	MCOUNT_RESTORE_FRAME
+ftrace_return:
 
 #ifdef CONFIG_FUNCTION_GRAPH_TRACER
 GLOBAL(ftrace_graph_call)
@@ -102,8 +130,78 @@ GLOBAL(ftrace_stub)
 	retq
 END(ftrace_caller)
 
+ENTRY(ftrace_regs_caller)
+	/* Save the current flags before compare (in SS location)*/
+	pushfq
+
+	/* Check if tracing was disabled (quick check) */
+	cmpl $0, function_trace_stop
+	jne  ftrace_restore_flags
+
+	/* skip=8 to skip flags saved in SS */
+	ftrace_caller_setup 8
+
+	/* Save the rest of pt_regs */
+	movq %r15, R15(%rsp)
+	movq %r14, R14(%rsp)
+	movq %r13, R13(%rsp)
+	movq %r12, R12(%rsp)
+	movq %r11, R11(%rsp)
+	movq %r10, R10(%rsp)
+	movq %rbp, RBP(%rsp)
+	movq %rbx, RBX(%rsp)
+	/* Copy saved flags */
+	movq SS(%rsp), %rcx
+	movq %rcx, EFLAGS(%rsp)
+	/* Kernel segments */
+	movq $__KERNEL_DS, %rcx
+	movq %rcx, SS(%rsp)
+	movq $__KERNEL_CS, %rcx
+	movq %rcx, CS(%rsp)
+	/* Stack - skipping return address */
+	leaq SS+16(%rsp), %rcx
+	movq %rcx, RSP(%rsp)
+
+	/* regs go into 4th parameter */
+	leaq (%rsp), %rcx
+
+GLOBAL(ftrace_regs_call)
+	call ftrace_stub
+
+	/* Copy flags back to SS, to restore them */
+	movq EFLAGS(%rsp), %rax
+	movq %rax, SS(%rsp)
+
+	/* Handlers can change the RIP */
+	movq RIP(%rsp), %rax
+	movq %rax, SS+8(%rsp)
+
+	/* restore the rest of pt_regs */
+	movq R15(%rsp), %r15
+	movq R14(%rsp), %r14
+	movq R13(%rsp), %r13
+	movq R12(%rsp), %r12
+	movq R10(%rsp), %r10
+	movq RBP(%rsp), %rbp
+	movq RBX(%rsp), %rbx
+
+	/* skip=8 to skip flags saved in SS */
+	MCOUNT_RESTORE_FRAME 8
+
+	/* Restore flags */
+	popfq
+
+	jmp ftrace_return
+ftrace_restore_flags:
+	popfq
+	jmp  ftrace_stub
+
+END(ftrace_regs_caller)
+
+
 #else /* ! CONFIG_DYNAMIC_FTRACE */
-ENTRY(mcount)
+
+ENTRY(function_hook)
 	cmpl $0, function_trace_stop
 	jne  ftrace_stub
 
@@ -124,8 +222,12 @@ GLOBAL(ftrace_stub)
 trace:
 	MCOUNT_SAVE_FRAME
 
-	movq 0x38(%rsp), %rdi
+	movq RIP(%rsp), %rdi
+#ifdef CC_USING_FENTRY
+	movq SS+16(%rsp), %rsi
+#else
 	movq 8(%rbp), %rsi
+#endif
 	subq $MCOUNT_INSN_SIZE, %rdi
 
 	call   *ftrace_trace_function
@@ -133,20 +235,22 @@ trace:
 	MCOUNT_RESTORE_FRAME
 
 	jmp ftrace_stub
-END(mcount)
+END(function_hook)
 #endif /* CONFIG_DYNAMIC_FTRACE */
 #endif /* CONFIG_FUNCTION_TRACER */
 
 #ifdef CONFIG_FUNCTION_GRAPH_TRACER
 ENTRY(ftrace_graph_caller)
-	cmpl $0, function_trace_stop
-	jne ftrace_stub
-
 	MCOUNT_SAVE_FRAME
 
+#ifdef CC_USING_FENTRY
+	leaq SS+16(%rsp), %rdi
+	movq $0, %rdx	/* No framepointers needed */
+#else
 	leaq 8(%rbp), %rdi
-	movq 0x38(%rsp), %rsi
 	movq (%rbp), %rdx
+#endif
+	movq RIP(%rsp), %rsi
 	subq $MCOUNT_INSN_SIZE, %rsi
 
 	call	prepare_ftrace_return
@@ -376,15 +480,15 @@ NMI_MASK = 0x80000000
 	.macro SAVE_ARGS_IRQ
 	cld
 	/* start from rbp in pt_regs and jump over */
-	movq_cfi rdi, RDI-RBP
-	movq_cfi rsi, RSI-RBP
-	movq_cfi rdx, RDX-RBP
-	movq_cfi rcx, RCX-RBP
-	movq_cfi rax, RAX-RBP
-	movq_cfi  r8,  R8-RBP
-	movq_cfi  r9,  R9-RBP
-	movq_cfi r10, R10-RBP
-	movq_cfi r11, R11-RBP
+	movq_cfi rdi, (RDI-RBP)
+	movq_cfi rsi, (RSI-RBP)
+	movq_cfi rdx, (RDX-RBP)
+	movq_cfi rcx, (RCX-RBP)
+	movq_cfi rax, (RAX-RBP)
+	movq_cfi  r8,  (R8-RBP)
+	movq_cfi  r9,  (R9-RBP)
+	movq_cfi r10, (R10-RBP)
+	movq_cfi r11, (R11-RBP)
 
 	/* Save rbp so that we can unwind from get_irq_regs() */
 	movq_cfi rbp, 0
@@ -419,7 +523,7 @@ NMI_MASK = 0x80000000
 #endif
 
 ENTRY(save_rest)
-	PARTIAL_FRAME 1 REST_SKIP+8
+	PARTIAL_FRAME 1 (REST_SKIP+8)
 	movq 5*8+16(%rsp), %r11	/* save return address */
 	movq_cfi rbx, RBX+16
 	movq_cfi rbp, RBP+16
@@ -477,7 +581,7 @@ ENTRY(ret_from_fork)
 
 	LOCK ; btr $TIF_FORK,TI_flags(%r8)
 
-	pushq_cfi kernel_eflags(%rip)
+	pushq_cfi $0x0002
 	popfq_cfi				# reset kernel eflags
 
 	call schedule_tail			# rdi: 'prev' task parameter
@@ -487,17 +591,24 @@ ENTRY(ret_from_fork)
 	RESTORE_REST
 
 	testl $3, CS-ARGOFFSET(%rsp)		# from kernel_thread?
-	jnz  1f
-	/* Need to set the proper %ss (not NULL) for ring 3 iretq */
-	movl $__KERNEL_DS,SS-ARGOFFSET(%rsp)
-	jmp  retint_restore_args
-1:
+	jz   1f
+
 	testl $_TIF_IA32, TI_flags(%rcx)	# 32-bit compat task needs IRET
 	jnz  int_ret_from_sys_call
 
 	RESTORE_TOP_OF_STACK %rdi, -ARGOFFSET
 	jmp ret_from_sys_call			# go to the SYSRET fastpath
 
+1:
+	/* Need to set the proper %ss (not NULL) for ring 3 iretq */
+	movl $__KERNEL_DS, SS-ARGOFFSET(%rsp)
+	subq $REST_SKIP, %rsp	# leave space for volatiles
+	CFI_ADJUST_CFA_OFFSET	REST_SKIP
+	movq %rbp, %rdi
+	call *%rbx
+	movl $0, RAX(%rsp)
+	RESTORE_REST
+	jmp int_ret_from_sys_call
 	CFI_ENDPROC
 END(ret_from_fork)
 
@@ -505,7 +616,8 @@ END(ret_from_fork)
  * System call entry. Up to 6 arguments in registers are supported.
  *
  * SYSCALL does not save anything on the stack and does not change the
- * stack pointer.
+ * stack pointer.  However, it does mask the flags register for us, so
+ * CLD and CLAC are not needed.
  */
 
 /*
@@ -582,7 +694,7 @@ sysret_careful:
 	TRACE_IRQS_ON
 	ENABLE_INTERRUPTS(CLBR_NONE)
 	pushq_cfi %rdi
-	call schedule
+	SCHEDULE_USER
 	popq_cfi %rdi
 	jmp sysret_check
 
@@ -695,7 +807,7 @@ int_careful:
 	TRACE_IRQS_ON
 	ENABLE_INTERRUPTS(CLBR_NONE)
 	pushq_cfi %rdi
-	call schedule
+	SCHEDULE_USER
 	popq_cfi %rdi
 	DISABLE_INTERRUPTS(CLBR_NONE)
 	TRACE_IRQS_OFF
@@ -774,7 +886,6 @@ ENTRY(stub_execve)
 	PARTIAL_FRAME 0
 	SAVE_REST
 	FIXUP_TOP_OF_STACK %r11
-	movq %rsp, %rcx
 	call sys_execve
 	RESTORE_TOP_OF_STACK %r11
 	movq %rax,RAX(%rsp)
@@ -824,8 +935,7 @@ ENTRY(stub_x32_execve)
 	PARTIAL_FRAME 0
 	SAVE_REST
 	FIXUP_TOP_OF_STACK %r11
-	movq %rsp, %rcx
-	call sys32_execve
+	call compat_sys_execve
 	RESTORE_TOP_OF_STACK %r11
 	movq %rax,RAX(%rsp)
 	RESTORE_REST
@@ -867,7 +977,7 @@ retint_careful:
 	TRACE_IRQS_ON
 	ENABLE_INTERRUPTS(CLBR_NONE)
 	pushq_cfi %rdi
-	call  schedule
+	SCHEDULE_USER
 	popq_cfi %rdi
 	GET_THREAD_INFO(%rcx)
 	DISABLE_INTERRUPTS(CLBR_NONE)
@@ -913,6 +1023,7 @@ END(retint_check)
  */
 .macro apicinterrupt num sym do_sym
 ENTRY(\sym)
+	ASM_CLAC
 	INTR_FRAME
 	pushq_cfi $~(\num)
 	interrupt \do_sym
@@ -968,6 +1079,7 @@ apicinterrupt IRQ_WORK_VECTOR \
 .macro zeroentry sym do_sym
 ENTRY(\sym)
 	INTR_FRAME
+	ASM_CLAC
         movq (%rsp),%rcx
 	CFI_RESTORE rcx
         movq 8(%rsp),%r11
@@ -996,6 +1108,7 @@ END(\sym)
 .macro errorentry sym do_sym
 ENTRY(\sym)
 	XCPT_FRAME
+	ASM_CLAC
         movq (%rsp),%rcx
 	CFI_RESTORE rcx
         movq 8(%rsp),%r11
@@ -1091,6 +1204,7 @@ ecrit:  /**** END OF CRITICAL REGION ***
 # with its current contents: any discrepancy means we in category 1.
 ENTRY(failsafe_callback)
 	INTR_FRAME offset=4*8
+	ASM_CLAC
 	movw %ds,%cx
 	cmpw %cx,0x10(%rsp)
 	CFI_REMEMBER_STATE
@@ -1138,53 +1252,6 @@ errorentry segment_not_present do_segmen
 zeroentry coprocessor_error do_coprocessor_error
 errorentry alignment_check do_alignment_check
 zeroentry simd_coprocessor_error do_simd_coprocessor_error
-	
-ENTRY(kernel_thread_helper)
-	pushq $0		# fake return address
-	CFI_STARTPROC
-	/*
-	 * Here we are in the child and the registers are set as they were
-	 * at kernel_thread() invocation in the parent.
-	 */
-	call *%rsi
-	# exit
-	mov %eax, %edi
-	call do_exit
-	ud2			# padding for call trace
-	CFI_ENDPROC
-END(kernel_thread_helper)
-
-/*
- * execve(). This function needs to use IRET, not SYSRET, to set up all state properly.
- *
- * C extern interface:
- *	 extern long execve(const char *name, char **argv, char **envp)
- *
- * asm input arguments:
- *	rdi: name, rsi: argv, rdx: envp
- *
- * We want to fallback into:
- *	extern long sys_execve(const char *name, char **argv,char **envp, struct pt_regs *regs)
- *
- * do_sys_execve asm fallback arguments:
- *	rdi: name, rsi: argv, rdx: envp, rcx: fake frame on the stack
- */
-ENTRY(kernel_execve)
-	CFI_STARTPROC
-	FAKE_STACK_FRAME $0
-	SAVE_ALL
-	movq %rsp,%rcx
-	call sys_execve
-	movq %rax, RAX(%rsp)
-	RESTORE_REST
-	testq %rax,%rax
-	jne 1f
-        jmp int_ret_from_sys_call
-1:      RESTORE_ARGS
-	UNFAKE_STACK_FRAME
-	ret
-	CFI_ENDPROC
-END(kernel_execve)
 
 /* Call softirq on interrupt stack. Interrupts are off. */
 ENTRY(call_softirq)
@@ -1278,7 +1345,7 @@ paranoid_userspace:
 paranoid_schedule:
 	TRACE_IRQS_ON
 	ENABLE_INTERRUPTS(CLBR_ANY)
-	call schedule
+	SCHEDULE_USER
 	DISABLE_INTERRUPTS(CLBR_ANY)
 	TRACE_IRQS_OFF
 	jmp paranoid_userspace
--- 12.3.orig/arch/x86/kernel/irq-xen.c	2012-09-05 15:48:38.000000000 +0200
+++ 12.3/arch/x86/kernel/irq-xen.c	2012-10-29 17:13:41.000000000 +0100
@@ -164,9 +164,7 @@ u64 arch_irq_stat_cpu(unsigned int cpu)
 #ifdef CONFIG_SMP
 	sum += irq_stats(cpu)->irq_resched_count;
 	sum += irq_stats(cpu)->irq_call_count;
-#ifndef CONFIG_XEN
-	sum += irq_stats(cpu)->irq_tlb_count;
-#else
+#ifdef CONFIG_XEN
 	sum += irq_stats(cpu)->irq_lock_count;
 #endif
 #endif
--- 12.3.orig/arch/x86/kernel/process-xen.c	2012-08-20 14:37:06.000000000 +0200
+++ 12.3/arch/x86/kernel/process-xen.c	2012-10-29 17:13:41.000000000 +0100
@@ -69,15 +69,13 @@ int arch_dup_task_struct(struct task_str
 {
 	int ret;
 
-	unlazy_fpu(src);
-
 	*dst = *src;
 	if (fpu_allocated(&src->thread.fpu)) {
 		memset(&dst->thread.fpu, 0, sizeof(dst->thread.fpu));
 		ret = fpu_alloc(&dst->thread.fpu);
 		if (ret)
 			return ret;
-		fpu_copy(&dst->thread.fpu, &src->thread.fpu);
+		fpu_copy(dst, src);
 	}
 	return 0;
 }
@@ -100,16 +98,6 @@ void arch_task_cache_init(void)
 				  SLAB_PANIC | SLAB_NOTRACK, NULL);
 }
 
-static inline void drop_fpu(struct task_struct *tsk)
-{
-	/*
-	 * Forget coprocessor state..
-	 */
-	tsk->fpu_counter = 0;
-	clear_fpu(tsk);
-	clear_used_math();
-}
-
 /*
  * Free current thread data structures etc..
  */
@@ -167,7 +155,13 @@ void flush_thread(void)
 
 	flush_ptrace_hw_breakpoint(tsk);
 	memset(tsk->thread.tls_array, 0, sizeof(tsk->thread.tls_array));
-	drop_fpu(tsk);
+	drop_init_fpu(tsk);
+	/*
+	 * Free the FPU state for non xsave platforms. They get reallocated
+	 * lazily at the first use.
+	 */
+	if (!use_eager_fpu())
+		free_thread_xstate(tsk);
 }
 
 static void hard_disable_TSC(void)
@@ -288,71 +282,6 @@ sys_clone(unsigned long clone_flags, uns
 }
 
 /*
- * This gets run with %si containing the
- * function to call, and %di containing
- * the "args".
- */
-extern void kernel_thread_helper(void);
-
-/*
- * Create a kernel thread
- */
-int kernel_thread(int (*fn)(void *), void *arg, unsigned long flags)
-{
-	struct pt_regs regs;
-
-	memset(&regs, 0, sizeof(regs));
-
-	regs.si = (unsigned long) fn;
-	regs.di = (unsigned long) arg;
-
-#ifdef CONFIG_X86_32
-	regs.ds = __USER_DS;
-	regs.es = __USER_DS;
-	regs.fs = __KERNEL_PERCPU;
-	regs.gs = __KERNEL_STACK_CANARY;
-#else
-	regs.ss = __KERNEL_DS;
-#endif
-
-	regs.orig_ax = -1;
-	regs.ip = (unsigned long) kernel_thread_helper;
-	regs.cs = __KERNEL_CS | get_kernel_rpl();
-	regs.flags = X86_EFLAGS_IF | X86_EFLAGS_BIT1;
-
-	/* Ok, create the new process.. */
-	return do_fork(flags | CLONE_VM | CLONE_UNTRACED, 0, &regs, 0, NULL, NULL);
-}
-EXPORT_SYMBOL(kernel_thread);
-
-/*
- * sys_execve() executes a new program.
- */
-long sys_execve(const char __user *name,
-		const char __user *const __user *argv,
-		const char __user *const __user *envp, struct pt_regs *regs)
-{
-	long error;
-	char *filename;
-
-	filename = getname(name);
-	error = PTR_ERR(filename);
-	if (IS_ERR(filename))
-		return error;
-	error = do_execve(filename, argv, envp, regs);
-
-#ifdef CONFIG_X86_32
-	if (error == 0) {
-		/* Make sure we don't return using sysenter.. */
-                set_thread_flag(TIF_IRET);
-        }
-#endif
-
-	putname(filename);
-	return error;
-}
-
-/*
  * Idle related variables and functions
  */
 unsigned long boot_option_idle_override = IDLE_NO_OVERRIDE;
--- 12.3.orig/arch/x86/kernel/process_32-xen.c	2012-08-01 12:17:51.000000000 +0200
+++ 12.3/arch/x86/kernel/process_32-xen.c	2012-10-29 17:13:41.000000000 +0100
@@ -60,6 +60,7 @@
 
 asmlinkage void ret_from_fork(void) __asm__("ret_from_fork");
 asmlinkage void cstar_ret_from_fork(void) __asm__("cstar_ret_from_fork");
+asmlinkage void ret_from_kernel_thread(void) __asm__("ret_from_kernel_thread");
 
 /*
  * Return saved PC of a blocked thread.
@@ -130,23 +131,39 @@ void release_thread(struct task_struct *
 }
 
 int copy_thread(unsigned long clone_flags, unsigned long sp,
-	unsigned long unused,
+	unsigned long arg,
 	struct task_struct *p, struct pt_regs *regs)
 {
-	struct pt_regs *childregs;
+	struct pt_regs *childregs = task_pt_regs(p);
 	struct task_struct *tsk;
 	int err;
 
-	childregs = task_pt_regs(p);
+	p->thread.sp = (unsigned long) childregs;
+	p->thread.sp0 = (unsigned long) (childregs+1);
+
+	if (unlikely(!regs)) {
+		/* kernel thread */
+		memset(childregs, 0, sizeof(struct pt_regs));
+		p->thread.ip = (unsigned long) ret_from_kernel_thread;
+		task_user_gs(p) = __KERNEL_STACK_CANARY;
+		childregs->ds = __USER_DS;
+		childregs->es = __USER_DS;
+		childregs->fs = __KERNEL_PERCPU;
+		childregs->bx = sp;	/* function */
+		childregs->bp = arg;
+		childregs->orig_ax = -1;
+		childregs->cs = __KERNEL_CS | get_kernel_rpl();
+		childregs->flags = X86_EFLAGS_IF | X86_EFLAGS_BIT1;
+		p->fpu_counter = 0;
+		p->thread.io_bitmap_ptr = NULL;
+		memset(p->thread.ptrace_bps, 0, sizeof(p->thread.ptrace_bps));
+		return 0;
+	}
 	*childregs = *regs;
 	childregs->ax = 0;
 	childregs->sp = sp;
 
-	p->thread.sp = (unsigned long) childregs;
-	p->thread.sp0 = (unsigned long) (childregs+1);
-
 	p->thread.ip = (unsigned long) ret_from_fork;
-
 	task_user_gs(p) = get_user_gs(regs);
 
 	p->fpu_counter = 0;
@@ -199,10 +216,12 @@ start_thread(struct pt_regs *regs, unsig
 	regs->cs		= __USER_CS;
 	regs->ip		= new_ip;
 	regs->sp		= new_sp;
+	regs->flags		= X86_EFLAGS_IF;
 	/*
-	 * Free the old FP and other extended state
+	 * force it to the iret return path by making it look as if there was
+	 * some work pending.
 	 */
-	free_thread_xstate(current);
+	set_thread_flag(TIF_NOTIFY_RESUME);
 }
 EXPORT_SYMBOL_GPL(start_thread);
 
--- 12.3.orig/arch/x86/kernel/process_64-xen.c	2012-08-20 14:37:06.000000000 +0200
+++ 12.3/arch/x86/kernel/process_64-xen.c	2012-10-29 17:13:41.000000000 +0100
@@ -155,28 +155,17 @@ static inline u32 read_32bit_tls(struct 
 }
 
 int copy_thread(unsigned long clone_flags, unsigned long sp,
-		unsigned long unused,
+		unsigned long arg,
 	struct task_struct *p, struct pt_regs *regs)
 {
 	int err;
 	struct pt_regs *childregs;
 	struct task_struct *me = current;
 
-	childregs = ((struct pt_regs *)
-			(THREAD_SIZE + task_stack_page(p))) - 1;
-	*childregs = *regs;
-
-	childregs->ax = 0;
-	if (user_mode(regs))
-		childregs->sp = sp;
-	else
-		childregs->sp = (unsigned long)childregs;
-
+	p->thread.sp0 = (unsigned long)task_stack_page(p) + THREAD_SIZE;
+	childregs = task_pt_regs(p);
 	p->thread.sp = (unsigned long) childregs;
-	p->thread.sp0 = (unsigned long) (childregs+1);
-
 	set_tsk_thread_flag(p, TIF_FORK);
-
 	p->fpu_counter = 0;
 	p->thread.io_bitmap_ptr = NULL;
 
@@ -186,6 +175,24 @@ int copy_thread(unsigned long clone_flag
 	p->thread.fs = p->thread.fsindex ? 0 : me->thread.fs;
 	savesegment(es, p->thread.es);
 	savesegment(ds, p->thread.ds);
+	memset(p->thread.ptrace_bps, 0, sizeof(p->thread.ptrace_bps));
+
+	if (unlikely(!regs)) {
+		/* kernel thread */
+		memset(childregs, 0, sizeof(struct pt_regs));
+		childregs->sp = (unsigned long)childregs;
+		childregs->ss = __KERNEL_DS;
+		childregs->bx = sp; /* function */
+		childregs->bp = arg;
+		childregs->orig_ax = -1;
+		childregs->cs = __KERNEL_CS | get_kernel_rpl();
+		childregs->flags = X86_EFLAGS_IF | X86_EFLAGS_BIT1;
+		return 0;
+	}
+	*childregs = *regs;
+
+	childregs->ax = 0;
+	childregs->sp = sp;
 
 	err = -ENOMEM;
 	memset(p->thread.ptrace_bps, 0, sizeof(p->thread.ptrace_bps));
@@ -240,10 +247,6 @@ start_thread_common(struct pt_regs *regs
 	regs->cs		= _cs;
 	regs->ss		= _ss;
 	regs->flags		= X86_EFLAGS_IF;
-	/*
-	 * Free the old FP and other extended state
-	 */
-	free_thread_xstate(current);
 }
 
 void
--- 12.3.orig/arch/x86/kernel/setup-xen.c	2012-08-20 14:37:06.000000000 +0200
+++ 12.3/arch/x86/kernel/setup-xen.c	2013-01-25 14:17:08.000000000 +0100
@@ -68,6 +68,7 @@
 #include <linux/percpu.h>
 #include <linux/crash_dump.h>
 #include <linux/tboot.h>
+#include <linux/jiffies.h>
 
 #include <video/edid.h>
 
@@ -1045,8 +1046,22 @@ void __init setup_arch(char **cmdline_p)
 
 #ifdef CONFIG_X86_64
 	if (max_pfn > max_low_pfn) {
-		max_pfn_mapped = init_memory_mapping(1UL<<32,
-						     max_pfn<<PAGE_SHIFT);
+		int i;
+		unsigned long start, end;
+		unsigned long start_pfn, end_pfn;
+
+		for_each_mem_pfn_range(i, MAX_NUMNODES, &start_pfn, &end_pfn,
+							 NULL) {
+
+			end = PFN_PHYS(end_pfn);
+			if (end <= (1UL<<32))
+				continue;
+
+			start = PFN_PHYS(start_pfn);
+			max_pfn_mapped = init_memory_mapping(
+						max((1UL<<32), start), end);
+		}
+
 		/* can we preseve max_low_pfn ?*/
 		max_low_pfn = max_pfn;
 	}
@@ -1092,13 +1107,11 @@ void __init setup_arch(char **cmdline_p)
 	initmem_init();
 	memblock_find_dma_reserve();
 
-#ifdef CONFIG_KVM_CLOCK
+#ifdef CONFIG_KVM_GUEST
 	kvmclock_init();
 #endif
 
-	x86_init.paging.pagetable_setup_start(swapper_pg_dir);
-	paging_init();
-	x86_init.paging.pagetable_setup_done(swapper_pg_dir);
+	x86_init.paging.pagetable_init();
 
 	if (boot_cpu_data.cpuid_level >= 0) {
 		/* A CPU has %cr4 if and only if it has CPUID */
@@ -1262,6 +1275,20 @@ void __init setup_arch(char **cmdline_p)
 	mcheck_init();
 
 	arch_init_ideal_nops();
+
+	register_refined_jiffies(CLOCK_TICK_RATE);
+
+#if defined(CONFIG_EFI) && !defined(CONFIG_XEN)
+	/* Once setup is done above, disable efi_enabled on mismatched
+	 * firmware/kernel archtectures since there is no support for
+	 * runtime services.
+	 */
+	if (efi_enabled && IS_ENABLED(CONFIG_X86_64) != efi_64bit) {
+		pr_info("efi: Setup done, disabling due to 32/64-bit mismatch\n");
+		efi_unmap_memmap();
+		efi_enabled = 0;
+	}
+#endif
 }
 
 #ifdef CONFIG_X86_32
--- 12.3.orig/arch/x86/kernel/traps-xen.c	2012-08-20 14:37:06.000000000 +0200
+++ 12.3/arch/x86/kernel/traps-xen.c	2013-11-27 11:33:30.000000000 +0100
@@ -55,6 +55,7 @@
 #include <asm/i387.h>
 #include <asm/fpu-internal.h>
 #include <asm/mce.h>
+#include <asm/rcu.h>
 
 #include <asm/mach_traps.h>
 
@@ -111,30 +112,45 @@ static inline void preempt_conditional_c
 	dec_preempt_count();
 }
 
-static void __kprobes
-do_trap(int trapnr, int signr, char *str, struct pt_regs *regs,
-	long error_code, siginfo_t *info)
+static int __kprobes
+do_trap_no_signal(struct task_struct *tsk, int trapnr, char *str,
+		  struct pt_regs *regs,	long error_code)
 {
-	struct task_struct *tsk = current;
-
 #ifdef CONFIG_X86_32
 	if (regs->flags & X86_VM_MASK) {
 		/*
-		 * traps 0, 1, 3, 4, and 5 should be forwarded to vm86.
+		 * Traps 0, 1, 3, 4, and 5 should be forwarded to vm86.
 		 * On nmi (interrupt 2), do_trap should not be called.
 		 */
-		if (trapnr < X86_TRAP_UD)
-			goto vm86_trap;
-		goto trap_signal;
+		if (trapnr < X86_TRAP_UD) {
+			if (!handle_vm86_trap((struct kernel_vm86_regs *) regs,
+						error_code, trapnr))
+				return 0;
+		}
+		return -1;
 	}
 #endif
+	if (!user_mode(regs)) {
+		if (!fixup_exception(regs)) {
+			tsk->thread.error_code = error_code;
+			tsk->thread.trap_nr = trapnr;
+			die(str, regs, error_code);
+		}
+		return 0;
+	}
 
-	if (!user_mode(regs))
-		goto kernel_trap;
+	return -1;
+}
 
-#ifdef CONFIG_X86_32
-trap_signal:
-#endif
+static void __kprobes
+do_trap(int trapnr, int signr, char *str, struct pt_regs *regs,
+	long error_code, siginfo_t *info)
+{
+	struct task_struct *tsk = current;
+
+
+	if (!do_trap_no_signal(tsk, trapnr, str, regs, error_code))
+		return;
 	/*
 	 * We want error_code and trap_nr set for userspace faults and
 	 * kernelspace faults which result in die(), but not
@@ -162,33 +178,20 @@ trap_signal:
 		force_sig_info(signr, info, tsk);
 	else
 		force_sig(signr, tsk);
-	return;
-
-kernel_trap:
-	if (!fixup_exception(regs)) {
-		tsk->thread.error_code = error_code;
-		tsk->thread.trap_nr = trapnr;
-		die(str, regs, error_code);
-	}
-	return;
-
-#ifdef CONFIG_X86_32
-vm86_trap:
-	if (handle_vm86_trap((struct kernel_vm86_regs *) regs,
-						error_code, trapnr))
-		goto trap_signal;
-	return;
-#endif
 }
 
 #define DO_ERROR(trapnr, signr, str, name)				\
 dotraplinkage void do_##name(struct pt_regs *regs, long error_code)	\
 {									\
-	if (notify_die(DIE_TRAP, str, regs, error_code, trapnr, signr)	\
-							== NOTIFY_STOP)	\
+	exception_enter(regs);						\
+	if (notify_die(DIE_TRAP, str, regs, error_code,			\
+			trapnr, signr) == NOTIFY_STOP) {		\
+		exception_exit(regs);					\
 		return;							\
+	}								\
 	conditional_sti(regs);						\
 	do_trap(trapnr, signr, str, regs, error_code, NULL);		\
+	exception_exit(regs);						\
 }
 
 #define DO_ERROR_INFO(trapnr, signr, str, name, sicode, siaddr)		\
@@ -199,11 +202,15 @@ dotraplinkage void do_##name(struct pt_r
 	info.si_errno = 0;						\
 	info.si_code = sicode;						\
 	info.si_addr = (void __user *)siaddr;				\
-	if (notify_die(DIE_TRAP, str, regs, error_code, trapnr, signr)	\
-							== NOTIFY_STOP)	\
+	exception_enter(regs);						\
+	if (notify_die(DIE_TRAP, str, regs, error_code,			\
+			trapnr, signr) == NOTIFY_STOP) {		\
+		exception_exit(regs);					\
 		return;							\
+	}								\
 	conditional_sti(regs);						\
 	do_trap(trapnr, signr, str, regs, error_code, &info);		\
+	exception_exit(regs);						\
 }
 
 DO_ERROR_INFO(X86_TRAP_DE, SIGFPE, "divide error", divide_error, FPE_INTDIV,
@@ -226,12 +233,14 @@ DO_ERROR_INFO(X86_TRAP_AC, SIGBUS, "alig
 /* Runs on IST stack */
 dotraplinkage void do_stack_segment(struct pt_regs *regs, long error_code)
 {
+	exception_enter(regs);
 	if (notify_die(DIE_TRAP, "stack segment", regs, error_code,
-			X86_TRAP_SS, SIGBUS) == NOTIFY_STOP)
-		return;
-	preempt_conditional_sti(regs);
-	do_trap(X86_TRAP_SS, SIGBUS, "stack segment", regs, error_code, NULL);
-	preempt_conditional_cli(regs);
+		       X86_TRAP_SS, SIGBUS) != NOTIFY_STOP) {
+		preempt_conditional_sti(regs);
+		do_trap(X86_TRAP_SS, SIGBUS, "stack segment", regs, error_code, NULL);
+		preempt_conditional_cli(regs);
+	}
+	exception_exit(regs);
 }
 
 dotraplinkage void do_double_fault(struct pt_regs *regs, long error_code)
@@ -239,6 +248,7 @@ dotraplinkage void do_double_fault(struc
 	static const char str[] = "double fault";
 	struct task_struct *tsk = current;
 
+	exception_enter(regs);
 	/* Return not checked because double check cannot be ignored */
 	notify_die(DIE_TRAP, str, regs, error_code, X86_TRAP_DF, SIGSEGV);
 
@@ -259,16 +269,29 @@ do_general_protection(struct pt_regs *re
 {
 	struct task_struct *tsk;
 
+	exception_enter(regs);
 	conditional_sti(regs);
 
 #ifdef CONFIG_X86_32
-	if (regs->flags & X86_VM_MASK)
-		goto gp_in_vm86;
+	if (regs->flags & X86_VM_MASK) {
+		local_irq_enable();
+		handle_vm86_fault((struct kernel_vm86_regs *) regs, error_code);
+		goto exit;
+	}
 #endif
 
 	tsk = current;
-	if (!user_mode(regs))
-		goto gp_in_kernel;
+	if (!user_mode(regs)) {
+		if (fixup_exception(regs))
+			goto exit;
+
+		tsk->thread.error_code = error_code;
+		tsk->thread.trap_nr = X86_TRAP_GP;
+		if (notify_die(DIE_GPF, "general protection fault", regs, error_code,
+			       X86_TRAP_GP, SIGSEGV) != NOTIFY_STOP)
+			die("general protection fault", regs, error_code);
+		goto exit;
+	}
 
 	tsk->thread.error_code = error_code;
 	tsk->thread.trap_nr = X86_TRAP_GP;
@@ -283,25 +306,8 @@ do_general_protection(struct pt_regs *re
 	}
 
 	force_sig(SIGSEGV, tsk);
-	return;
-
-#ifdef CONFIG_X86_32
-gp_in_vm86:
-	local_irq_enable();
-	handle_vm86_fault((struct kernel_vm86_regs *) regs, error_code);
-	return;
-#endif
-
-gp_in_kernel:
-	if (fixup_exception(regs))
-		return;
-
-	tsk->thread.error_code = error_code;
-	tsk->thread.trap_nr = X86_TRAP_GP;
-	if (notify_die(DIE_GPF, "general protection fault", regs, error_code,
-			X86_TRAP_GP, SIGSEGV) == NOTIFY_STOP)
-		return;
-	die("general protection fault", regs, error_code);
+exit:
+	exception_exit(regs);
 }
 
 /* May run on IST stack. */
@@ -316,15 +322,16 @@ dotraplinkage void __kprobes notrace do_
 	    ftrace_int3_handler(regs))
 		return;
 #endif
+	exception_enter(regs);
 #ifdef CONFIG_KGDB_LOW_LEVEL_TRAP
 	if (kgdb_ll_trap(DIE_INT3, "int3", regs, error_code, X86_TRAP_BP,
 				SIGTRAP) == NOTIFY_STOP)
-		return;
+		goto exit;
 #endif /* CONFIG_KGDB_LOW_LEVEL_TRAP */
 
 	if (notify_die(DIE_INT3, "int3", regs, error_code, X86_TRAP_BP,
 			SIGTRAP) == NOTIFY_STOP)
-		return;
+		goto exit;
 
 	/*
 	 * Let others (NMI) know that the debug stack is in use
@@ -335,6 +342,8 @@ dotraplinkage void __kprobes notrace do_
 	do_trap(X86_TRAP_BP, SIGTRAP, "int3", regs, error_code, NULL);
 	preempt_conditional_cli(regs);
 	debug_stack_usage_dec();
+exit:
+	exception_exit(regs);
 }
 
 #if defined(CONFIG_X86_64) && !defined(CONFIG_XEN)
@@ -395,6 +404,8 @@ dotraplinkage void __kprobes do_debug(st
 	unsigned long dr6;
 	int si_code;
 
+	exception_enter(regs);
+
 	get_debugreg(dr6, 6);
 
 	/* Filter out all the reserved bits which are preset to 1 */
@@ -410,7 +421,7 @@ dotraplinkage void __kprobes do_debug(st
 
 	/* Catch kmemcheck conditions first of all! */
 	if ((dr6 & DR_STEP) && kmemcheck_trap(regs))
-		return;
+		goto exit;
 
 	/* DR6 may or may not be cleared by the CPU */
 	set_debugreg(0, 6);
@@ -425,7 +436,7 @@ dotraplinkage void __kprobes do_debug(st
 
 	if (notify_die(DIE_DEBUG, "debug", regs, PTR_ERR(&dr6), error_code,
 							SIGTRAP) == NOTIFY_STOP)
-		return;
+		goto exit;
 
 	/*
 	 * Let others (NMI) know that the debug stack is in use
@@ -441,7 +452,7 @@ dotraplinkage void __kprobes do_debug(st
 					X86_TRAP_DB);
 		preempt_conditional_cli(regs);
 		debug_stack_usage_dec();
-		return;
+		goto exit;
 	}
 
 	/*
@@ -462,7 +473,8 @@ dotraplinkage void __kprobes do_debug(st
 	preempt_conditional_cli(regs);
 	debug_stack_usage_dec();
 
-	return;
+exit:
+	exception_exit(regs);
 }
 
 /*
@@ -559,14 +571,17 @@ dotraplinkage void do_coprocessor_error(
 #ifdef CONFIG_X86_32
 	ignore_fpu_irq = 1;
 #endif
-
+	exception_enter(regs);
 	math_error(regs, error_code, X86_TRAP_MF);
+	exception_exit(regs);
 }
 
 dotraplinkage void
 do_simd_coprocessor_error(struct pt_regs *regs, long error_code)
 {
+	exception_enter(regs);
 	math_error(regs, error_code, X86_TRAP_XF);
+	exception_exit(regs);
 }
 
 #ifndef CONFIG_XEN
@@ -623,11 +638,12 @@ void math_state_restore(void)
 	}
 
 	xen_thread_fpu_begin(tsk, NULL);
+
 	/*
 	 * Paranoid restore. send a SIGSEGV if we fail to restore the state.
 	 */
 	if (unlikely(restore_fpu_checking(tsk))) {
-		__thread_fpu_end(tsk);
+		drop_init_fpu(tsk);
 		force_sig(SIGSEGV, tsk);
 		return;
 	}
@@ -638,6 +654,9 @@ void math_state_restore(void)
 dotraplinkage void __kprobes
 do_device_not_available(struct pt_regs *regs, long error_code)
 {
+	exception_enter(regs);
+	BUG_ON(use_eager_fpu());
+
 #ifdef CONFIG_MATH_EMULATION
 	if (read_cr0() & X86_CR0_EM) {
 		struct math_emu_info info = { };
@@ -646,6 +665,7 @@ do_device_not_available(struct pt_regs *
 
 		info.regs = regs;
 		math_emulate(&info);
+		exception_exit(regs);
 		return;
 	}
 #endif
@@ -653,12 +673,15 @@ do_device_not_available(struct pt_regs *
 #ifdef CONFIG_X86_32
 	conditional_sti(regs);
 #endif
+	exception_exit(regs);
 }
 
 #ifdef CONFIG_X86_32
 dotraplinkage void do_iret_error(struct pt_regs *regs, long error_code)
 {
 	siginfo_t info;
+
+	exception_enter(regs);
 	local_irq_enable();
 
 	info.si_signo = SIGILL;
@@ -666,10 +689,11 @@ dotraplinkage void do_iret_error(struct 
 	info.si_code = ILL_BADSTK;
 	info.si_addr = NULL;
 	if (notify_die(DIE_TRAP, "iret exception", regs, error_code,
-			X86_TRAP_IRET, SIGILL) == NOTIFY_STOP)
-		return;
-	do_trap(X86_TRAP_IRET, SIGILL, "iret exception", regs, error_code,
-		&info);
+			X86_TRAP_IRET, SIGILL) != NOTIFY_STOP) {
+		do_trap(X86_TRAP_IRET, SIGILL, "iret exception", regs, error_code,
+			&info);
+	}
+	exception_exit(regs);
 }
 #endif
 
--- 12.3.orig/arch/x86/kernel/vsyscall_64-xen.c	2012-08-20 14:37:06.000000000 +0200
+++ 12.3/arch/x86/kernel/vsyscall_64-xen.c	2012-10-29 17:13:41.000000000 +0100
@@ -28,7 +28,7 @@
 #include <linux/jiffies.h>
 #include <linux/sysctl.h>
 #include <linux/topology.h>
-#include <linux/clocksource.h>
+#include <linux/timekeeper_internal.h>
 #include <linux/getcpu.h>
 #include <linux/cpu.h>
 #include <linux/smp.h>
@@ -82,34 +82,43 @@ void update_vsyscall_tz(void)
 	vsyscall_gtod_data.sys_tz = sys_tz;
 }
 
-void update_vsyscall(struct timespec *wall_time, struct timespec *wtm,
-			struct clocksource *clock, u32 mult)
+void update_vsyscall(struct timekeeper *tk)
 {
-	struct timespec monotonic;
+	struct vsyscall_gtod_data *vdata = &vsyscall_gtod_data;
 
-	write_seqcount_begin(&vsyscall_gtod_data.seq);
+	write_seqcount_begin(&vdata->seq);
 
 	/* copy vsyscall data */
 #ifndef CONFIG_XEN
-	vsyscall_gtod_data.clock.vclock_mode	= clock->archdata.vclock_mode;
+	vdata->clock.vclock_mode	= tk->clock->archdata.vclock_mode;
 #endif
-	vsyscall_gtod_data.clock.cycle_last	= clock->cycle_last;
-	vsyscall_gtod_data.clock.mask		= clock->mask;
-	vsyscall_gtod_data.clock.mult		= mult;
-	vsyscall_gtod_data.clock.shift		= clock->shift;
-
-	vsyscall_gtod_data.wall_time_sec	= wall_time->tv_sec;
-	vsyscall_gtod_data.wall_time_nsec	= wall_time->tv_nsec;
-
-	monotonic = timespec_add(*wall_time, *wtm);
-	vsyscall_gtod_data.monotonic_time_sec	= monotonic.tv_sec;
-	vsyscall_gtod_data.monotonic_time_nsec	= monotonic.tv_nsec;
-
-	vsyscall_gtod_data.wall_time_coarse	= __current_kernel_time();
-	vsyscall_gtod_data.monotonic_time_coarse =
-		timespec_add(vsyscall_gtod_data.wall_time_coarse, *wtm);
+	vdata->clock.cycle_last		= tk->clock->cycle_last;
+	vdata->clock.mask		= tk->clock->mask;
+	vdata->clock.mult		= tk->mult;
+	vdata->clock.shift		= tk->shift;
+
+	vdata->wall_time_sec		= tk->xtime_sec;
+	vdata->wall_time_snsec		= tk->xtime_nsec;
+
+	vdata->monotonic_time_sec	= tk->xtime_sec
+					+ tk->wall_to_monotonic.tv_sec;
+	vdata->monotonic_time_snsec	= tk->xtime_nsec
+					+ (tk->wall_to_monotonic.tv_nsec
+						<< tk->shift);
+	while (vdata->monotonic_time_snsec >=
+					(((u64)NSEC_PER_SEC) << tk->shift)) {
+		vdata->monotonic_time_snsec -=
+					((u64)NSEC_PER_SEC) << tk->shift;
+		vdata->monotonic_time_sec++;
+	}
+
+	vdata->wall_time_coarse.tv_sec	= tk->xtime_sec;
+	vdata->wall_time_coarse.tv_nsec	= (long)(tk->xtime_nsec >> tk->shift);
+
+	vdata->monotonic_time_coarse	= timespec_add(vdata->wall_time_coarse,
+							tk->wall_to_monotonic);
 
-	write_seqcount_end(&vsyscall_gtod_data.seq);
+	write_seqcount_end(&vdata->seq);
 }
 
 static void warn_bad_vsyscall(const char *level, struct pt_regs *regs,
--- 12.3.orig/arch/x86/kernel/x86_init-xen.c	2012-08-20 14:37:06.000000000 +0200
+++ 12.3/arch/x86/kernel/x86_init-xen.c	2012-10-29 17:13:41.000000000 +0100
@@ -25,7 +25,6 @@
 
 void __cpuinit x86_init_noop(void) { }
 void __init x86_init_uint_noop(unsigned int unused) { }
-void __init x86_init_pgd_noop(pgd_t *unused) { }
 int __init iommu_init_noop(void) { return 0; }
 
 /*
@@ -70,8 +69,7 @@ struct x86_init_ops x86_init __initdata 
 	},
 
 	.paging = {
-		.pagetable_setup_start	= x86_init_pgd_noop,
-		.pagetable_setup_done	= x86_init_pgd_noop,
+		.pagetable_init		= xen_pagetable_init,
 	},
 
 	.timers = {
--- 12.3.orig/arch/x86/mm/fault-xen.c	2012-06-14 11:23:26.000000000 +0200
+++ 12.3/arch/x86/mm/fault-xen.c	2012-10-29 17:13:41.000000000 +0100
@@ -18,6 +18,7 @@
 #include <asm/pgalloc.h>		/* pgd_*(), ...			*/
 #include <asm/kmemcheck.h>		/* kmemcheck_*(), ...		*/
 #include <asm/fixmap.h>			/* VSYSCALL_START		*/
+#include <asm/rcu.h>			/* exception_enter(), ...	*/
 
 /*
  * Page fault error code bits:
@@ -1004,13 +1005,24 @@ static int fault_in_kernel_space(unsigne
 	return address >= TASK_SIZE_MAX;
 }
 
+static inline bool smap_violation(int error_code, struct pt_regs *regs)
+{
+	if (error_code & PF_USER)
+		return false;
+
+	if (!user_mode_vm(regs) && (regs->flags & X86_EFLAGS_AC))
+		return false;
+
+	return true;
+}
+
 /*
  * This routine handles page faults.  It determines the address,
  * and the problem, and then passes it off to one of the appropriate
  * routines.
  */
-dotraplinkage void __kprobes
-do_page_fault(struct pt_regs *regs, unsigned long error_code)
+static void __kprobes
+__do_page_fault(struct pt_regs *regs, unsigned long error_code)
 {
 	struct vm_area_struct *vma;
 	struct task_struct *tsk;
@@ -1114,6 +1126,13 @@ do_page_fault(struct pt_regs *regs, unsi
 	if (unlikely(error_code & PF_RSVD))
 		pgtable_bad(regs, error_code, address);
 
+	if (static_cpu_has(X86_FEATURE_SMAP)) {
+		if (unlikely(smap_violation(error_code, regs))) {
+			bad_area_nosemaphore(regs, error_code, address);
+			return;
+		}
+	}
+
 	perf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, regs, address);
 
 	/*
@@ -1227,6 +1246,7 @@ good_area:
 			/* Clear FAULT_FLAG_ALLOW_RETRY to avoid any risk
 			 * of starvation. */
 			flags &= ~FAULT_FLAG_ALLOW_RETRY;
+			flags |= FAULT_FLAG_TRIED;
 			goto retry;
 		}
 	}
@@ -1235,3 +1255,11 @@ good_area:
 
 	up_read(&mm->mmap_sem);
 }
+
+dotraplinkage void __kprobes
+do_page_fault(struct pt_regs *regs, unsigned long error_code)
+{
+	exception_enter(regs);
+	__do_page_fault(regs, error_code);
+	exception_exit(regs);
+}
--- 12.3.orig/arch/x86/mm/init-xen.c	2012-10-04 13:21:48.000000000 +0200
+++ 12.3/arch/x86/mm/init-xen.c	2012-10-31 11:57:31.000000000 +0100
@@ -42,39 +42,42 @@ struct map_range {
 	unsigned page_size_mask;
 };
 
-static void __init find_early_table_space(struct map_range *mr, unsigned long end,
-					  int use_pse, int use_gbpages)
+/*
+ * First calculate space needed for kernel direct mapping page tables to cover
+ * mr[0].start to mr[nr_range - 1].end, while accounting for possible 2M and 1GB
+ * pages. Then find enough contiguous space for those page tables.
+ */
+static void __init find_early_table_space(struct map_range *mr, int nr_range)
 {
-	unsigned long puds, pmds, ptes, tables;
-
-	puds = (end + PUD_SIZE - 1) >> PUD_SHIFT;
-	tables = roundup(puds * sizeof(pud_t), PAGE_SIZE);
-
-	if (use_gbpages) {
-		unsigned long extra;
+	int i;
+	unsigned long puds = 0, pmds = 0, ptes = 0, tables;
 
-		extra = end - ((end>>PUD_SHIFT) << PUD_SHIFT);
-		pmds = (extra + PMD_SIZE - 1) >> PMD_SHIFT;
-	} else
-		pmds = (end + PMD_SIZE - 1) >> PMD_SHIFT;
+	for (i = 0; i < nr_range; i++) {
+		unsigned long range, extra;
 
-	tables += roundup(pmds * sizeof(pmd_t), PAGE_SIZE);
+		range = mr[i].end - mr[i].start;
+		puds += (range + PUD_SIZE - 1) >> PUD_SHIFT;
 
-	if (use_pse) {
-		unsigned long extra;
+		if (mr[i].page_size_mask & (1 << PG_LEVEL_1G)) {
+			extra = range - ((range >> PUD_SHIFT) << PUD_SHIFT);
+			pmds += (extra + PMD_SIZE - 1) >> PMD_SHIFT;
+		} else {
+			pmds += (range + PMD_SIZE - 1) >> PMD_SHIFT;
+		}
 
-		extra = end - ((end>>PMD_SHIFT) << PMD_SHIFT);
+		if (mr[i].page_size_mask & (1 << PG_LEVEL_2M)) {
+			extra = range - ((range >> PMD_SHIFT) << PMD_SHIFT);
 #ifdef CONFIG_X86_32
-		extra += PMD_SIZE;
+			extra += PMD_SIZE;
 #endif
-		/* The first 2/4M doesn't use large pages. */
-		if (mr->start < PMD_SIZE)
-			extra += mr->end - mr->start;
-
-		ptes = (extra + PAGE_SIZE - 1) >> PAGE_SHIFT;
-	} else
-		ptes = (end + PAGE_SIZE - 1) >> PAGE_SHIFT;
+			ptes += (extra + PAGE_SIZE - 1) >> PAGE_SHIFT;
+		} else {
+			ptes += (range + PAGE_SIZE - 1) >> PAGE_SHIFT;
+		}
+	}
 
+	tables = roundup(puds * sizeof(pud_t), PAGE_SIZE);
+	tables += roundup(pmds * sizeof(pmd_t), PAGE_SIZE);
 	tables += roundup(ptes * sizeof(pte_t), PAGE_SIZE);
 
 #ifdef CONFIG_X86_32
@@ -104,7 +107,7 @@ static void __init find_early_table_spac
 	pgt_buf_top = pgt_buf_start + (tables >> PAGE_SHIFT);
 
 	printk(KERN_DEBUG "kernel direct mapping tables up to %#lx @ [mem %#010lx-%#010lx]\n",
-		end - 1, pgt_buf_start << PAGE_SHIFT,
+		mr[nr_range - 1].end - 1, pgt_buf_start << PAGE_SHIFT,
 		(pgt_buf_top << PAGE_SHIFT) - 1);
 }
 
@@ -286,7 +289,7 @@ unsigned long __init_refok init_memory_m
 	 * nodes are discovered.
 	 */
 	if (!after_bootmem)
-		find_early_table_space(&mr[0], end, use_pse, use_gbpages);
+		find_early_table_space(mr, nr_range);
 
 #ifdef CONFIG_X86_64
 #define addr_to_page(addr)						\
--- 12.3.orig/arch/x86/mm/init_32-xen.c	2012-04-11 13:26:23.000000000 +0200
+++ 12.3/arch/x86/mm/init_32-xen.c	2012-10-29 17:13:41.000000000 +0100
@@ -495,7 +495,7 @@ pgd_t *swapper_pg_dir;
  * If we're booting paravirtualized under a hypervisor, then there are
  * more options: we may already be running PAE, and the pagetable may
  * or may not be based in swapper_pg_dir.  In any case,
- * paravirt_pagetable_setup_start() will set up swapper_pg_dir
+ * paravirt_pagetable_init() will set up swapper_pg_dir
  * appropriately for the rest of the initialization to work.
  *
  * In general, pagetable_init() assumes that the pagetable may already
@@ -765,7 +765,7 @@ static void __init test_wp_bit(void)
   "Checking if this processor honours the WP bit even in supervisor mode...");
 
 	/* Any page-aligned address will do, the test is non-destructive */
-	__set_fixmap(FIX_WP_TEST, __pa(&swapper_pg_dir), PAGE_READONLY);
+	__set_fixmap(FIX_WP_TEST, __pa(&swapper_pg_dir), PAGE_KERNEL_RO);
 	boot_cpu_data.wp_works_ok = do_test_wp_bit();
 	clear_fixmap(FIX_WP_TEST);
 
--- 12.3.orig/arch/x86/mm/init_64-xen.c	2012-06-14 11:23:26.000000000 +0200
+++ 12.3/arch/x86/mm/init_64-xen.c	2012-10-31 11:57:31.000000000 +0100
@@ -491,7 +491,8 @@ phys_pte_init(pte_t *pte_page, unsigned 
 		 * these mappings are more intelligent.
 		 */
 		if (__pte_val(*pte)) {
-			pages++;
+			if (!after_bootmem)
+				pages++;
 			continue;
 		}
 
@@ -556,6 +557,8 @@ phys_pmd_init(pmd_t *pmd_page, unsigned 
 			 * attributes.
 			 */
 			if (page_size_mask & (1 << PG_LEVEL_2M)) {
+				if (!after_bootmem)
+					pages++;
 				last_map_addr = next;
 				continue;
 			}
@@ -644,6 +647,8 @@ phys_pud_init(pud_t *pud_page, unsigned 
 			 * attributes.
 			 */
 			if (page_size_mask & (1 << PG_LEVEL_1G)) {
+				if (!after_bootmem)
+					pages++;
 				last_map_addr = next;
 				continue;
 			}
--- 12.3.orig/arch/x86/mm/ioremap-xen.c	2012-06-19 12:14:10.000000000 +0200
+++ 12.3/arch/x86/mm/ioremap-xen.c	2012-12-06 16:18:40.000000000 +0100
@@ -118,8 +118,7 @@ int direct_remap_pfn_range(struct vm_are
 	if (domid == DOMID_SELF)
 		return -EINVAL;
 
-	vma->vm_flags |= VM_IO | VM_RESERVED | VM_PFNMAP;
-
+	vma->vm_flags |= VM_IO | VM_PFNMAP | VM_DONTEXPAND | VM_DONTDUMP;
 	vma->vm_mm->context.has_foreign_mappings = 1;
 
 	return __direct_remap_pfn_range(
--- 12.3.orig/arch/x86/mm/pat-xen.c	2012-06-14 11:23:26.000000000 +0200
+++ 12.3/arch/x86/mm/pat-xen.c	2012-10-29 17:13:41.000000000 +0100
@@ -660,20 +660,20 @@ static void free_pfn_range(u64 paddr, un
 }
 
 /*
- * track_pfn_vma_copy is called when vma that is covering the pfnmap gets
+ * track_pfn_copy is called when vma that is covering the pfnmap gets
  * copied through copy_page_range().
  *
  * If the vma has a linear pfn mapping for the entire range, we get the prot
  * from pte and reserve the entire vma range with single reserve_pfn_range call.
  */
-int track_pfn_vma_copy(struct vm_area_struct *vma)
+int track_pfn_copy(struct vm_area_struct *vma)
 {
 	resource_size_t paddr;
 	unsigned long prot;
 	unsigned long vma_size = vma->vm_end - vma->vm_start;
 	pgprot_t pgprot;
 
-	if (is_linear_pfn_mapping(vma)) {
+	if (vma->vm_flags & VM_PAT) {
 		/*
 		 * reserve the whole chunk covered by vma. We need the
 		 * starting address and protection from pte.
@@ -690,31 +690,59 @@ int track_pfn_vma_copy(struct vm_area_st
 }
 
 /*
- * track_pfn_vma_new is called when a _new_ pfn mapping is being established
- * for physical range indicated by pfn and size.
- *
  * prot is passed in as a parameter for the new mapping. If the vma has a
  * linear pfn mapping for the entire range reserve the entire vma range with
  * single reserve_pfn_range call.
  */
-int track_pfn_vma_new(struct vm_area_struct *vma, pgprot_t *prot,
-			unsigned long pfn, unsigned long size)
+int track_pfn_remap(struct vm_area_struct *vma, pgprot_t *prot,
+		    unsigned long pfn, unsigned long addr, unsigned long size)
 {
+	resource_size_t paddr = (resource_size_t)pfn << PAGE_SHIFT;
 	unsigned long flags;
-	resource_size_t paddr;
-	unsigned long vma_size = vma->vm_end - vma->vm_start;
 
-	if (is_linear_pfn_mapping(vma)) {
-		/* reserve the whole chunk starting from vm_pgoff */
-		paddr = (resource_size_t)vma->vm_pgoff << PAGE_SHIFT;
-		return reserve_pfn_range(paddr, vma_size, prot, 0);
+	/* reserve the whole chunk starting from paddr */
+	if (addr == vma->vm_start && size == (vma->vm_end - vma->vm_start)) {
+		int ret;
+
+		ret = reserve_pfn_range(paddr, size, prot, 0);
+		if (!ret)
+			vma->vm_flags |= VM_PAT;
+		return ret;
 	}
 
 	if (!pat_enabled)
 		return 0;
 
-	/* for vm_insert_pfn and friends, we set prot based on lookup */
-	flags = lookup_memtype(pfn << PAGE_SHIFT);
+	/*
+	 * For anything smaller than the vma size we set prot based on the
+	 * lookup.
+	 */
+	flags = lookup_memtype(paddr);
+
+	/* Check memtype for the remaining pages */
+	while (size > PAGE_SIZE) {
+		size -= PAGE_SIZE;
+		paddr += PAGE_SIZE;
+		if (flags != lookup_memtype(paddr))
+			return -EINVAL;
+	}
+
+	*prot = __pgprot((pgprot_val(vma->vm_page_prot) & (~_PAGE_CACHE_MASK)) |
+			 flags);
+
+	return 0;
+}
+
+int track_pfn_insert(struct vm_area_struct *vma, pgprot_t *prot,
+		     unsigned long pfn)
+{
+	unsigned long flags;
+
+	if (!pat_enabled)
+		return 0;
+
+	/* Set prot based on lookup */
+	flags = lookup_memtype((resource_size_t)pfn << PAGE_SHIFT);
 	*prot = __pgprot((pgprot_val(vma->vm_page_prot) & (~_PAGE_CACHE_MASK)) |
 			 flags);
 
@@ -722,22 +750,31 @@ int track_pfn_vma_new(struct vm_area_str
 }
 
 /*
- * untrack_pfn_vma is called while unmapping a pfnmap for a region.
+ * untrack_pfn is called while unmapping a pfnmap for a region.
  * untrack can be called for a specific region indicated by pfn and size or
- * can be for the entire vma (in which case size can be zero).
+ * can be for the entire vma (in which case pfn, size are zero).
  */
-void untrack_pfn_vma(struct vm_area_struct *vma, unsigned long pfn,
-			unsigned long size)
+void untrack_pfn(struct vm_area_struct *vma, unsigned long pfn,
+		 unsigned long size)
 {
 	resource_size_t paddr;
-	unsigned long vma_size = vma->vm_end - vma->vm_start;
+	unsigned long prot;
 
-	if (is_linear_pfn_mapping(vma)) {
-		/* free the whole chunk starting from vm_pgoff */
-		paddr = (resource_size_t)vma->vm_pgoff << PAGE_SHIFT;
-		free_pfn_range(paddr, vma_size);
+	if (!(vma->vm_flags & VM_PAT))
 		return;
+
+	/* free the chunk starting from pfn or the whole chunk */
+	paddr = (resource_size_t)pfn << PAGE_SHIFT;
+	if (!paddr && !size) {
+		if (follow_phys(vma, vma->vm_start, 0, &prot, &paddr)) {
+			WARN_ON_ONCE(1);
+			return;
+		}
+
+		size = vma->vm_end - vma->vm_start;
 	}
+	free_pfn_range(paddr, size);
+	vma->vm_flags &= ~VM_PAT;
 }
 #endif /* CONFIG_XEN */
 
--- 12.3.orig/arch/x86/mm/tlb-xen.c	2012-08-21 17:36:04.000000000 +0200
+++ 12.3/arch/x86/mm/tlb-xen.c	2012-12-06 16:25:52.000000000 +0100
@@ -57,7 +57,7 @@ void flush_tlb_mm_range(struct mm_struct
 	}
 
 	if (end == TLB_FLUSH_ALL || tlb_flushall_shift == -1
-				 || vmflag == VM_HUGETLB)
+				 || vmflag & VM_HUGETLB)
 		goto flush_all;
 
 	/* In modern CPU, last level tlb used for both data/ins */
--- 12.3.orig/drivers/acpi/processor_idle.c	2013-02-05 10:55:54.000000000 +0100
+++ 12.3/drivers/acpi/processor_idle.c	2013-02-05 10:56:50.000000000 +0100
@@ -1254,7 +1254,6 @@ static int acpi_processor_registered;
 int __cpuinit acpi_processor_power_init(struct acpi_processor *pr)
 {
 	acpi_status status = 0;
-	struct cpuidle_device *dev;
 	static int first_run;
 
 	if (disabled_by_idle_boot_param())
@@ -1292,6 +1291,7 @@ int __cpuinit acpi_processor_power_init(
 	 * platforms that only support C1.
 	 */
 	if (pr->flags.power) {
+		struct cpuidle_device *dev;
 		int retval;
 
 		/* Register acpi_idle_driver if not already registered */
--- 12.3.orig/drivers/char/tpm/tpm.h	2012-10-22 17:20:59.000000000 +0200
+++ 12.3/drivers/char/tpm/tpm.h	2012-11-14 16:18:45.000000000 +0100
@@ -129,9 +129,6 @@ struct tpm_chip {
 	struct dentry **bios_dir;
 
 	struct list_head list;
-#ifdef CONFIG_XEN
-	void *priv;
-#endif
 	void (*release) (struct device *);
 };
 
@@ -313,17 +310,15 @@ struct tpm_cmd_t {
 
 ssize_t	tpm_getcap(struct device *, __be32, cap_t *, const char *);
 
-#ifdef CONFIG_XEN
 static inline void *chip_get_private(const struct tpm_chip *chip)
 {
-	return chip->priv;
+	return chip->vendor.data;
 }
 
 static inline void chip_set_private(struct tpm_chip *chip, void *priv)
 {
-	chip->priv = priv;
+	chip->vendor.data = priv;
 }
-#endif
 
 extern int tpm_get_timeouts(struct tpm_chip *);
 extern void tpm_gen_interrupt(struct tpm_chip *);
--- 12.3.orig/drivers/hwmon/coretemp-xen.c	2012-08-20 14:37:06.000000000 +0200
+++ 12.3/drivers/hwmon/coretemp-xen.c	2012-10-29 17:13:41.000000000 +0100
@@ -213,8 +213,11 @@ static const struct tjmax tjmax_table[] 
 	{ "CPU N455", 100000 },
 	{ "CPU N470", 100000 },
 	{ "CPU N475", 100000 },
-	{ "CPU  230", 100000 },
-	{ "CPU  330", 125000 },
+	{ "CPU  230", 100000 },		/* Model 0x1c, stepping 2	*/
+	{ "CPU  330", 125000 },		/* Model 0x1c, stepping 2	*/
+	{ "CPU CE4110", 110000 },	/* Model 0x1c, stepping 10	*/
+	{ "CPU CE4150", 110000 },	/* Model 0x1c, stepping 10	*/
+	{ "CPU CE4170", 110000 },	/* Model 0x1c, stepping 10	*/
 };
 
 static int adjust_tjmax(struct platform_data *c, u32 id, struct device *dev)
--- 12.3.orig/drivers/remoteproc/Kconfig	2013-11-27 11:08:55.000000000 +0100
+++ 12.3/drivers/remoteproc/Kconfig	2012-11-02 12:55:30.000000000 +0100
@@ -1,4 +1,5 @@
 menu "Remoteproc drivers (EXPERIMENTAL)"
+	depends on !XEN # not compatible with the selection of VIRTIO below
 
 # REMOTEPROC gets selected by whoever wants it
 config REMOTEPROC
--- 12.3.orig/drivers/xen/Makefile	2012-08-20 14:37:06.000000000 +0200
+++ 12.3/drivers/xen/Makefile	2012-11-14 13:25:08.000000000 +0100
@@ -1,10 +1,16 @@
-obj-$(CONFIG_PARAVIRT_XEN)	+= grant-table.o features.o events.o manage.o balloon.o
 xen-biomerge-$(CONFIG_PARAVIRT_XEN) := biomerge.o
 xen-hotplug-$(CONFIG_PARAVIRT_XEN) := cpu_hotplug.o
 xen-balloon_$(CONFIG_PARAVIRT_XEN) := xen-balloon.o
 xen-evtchn-name-$(CONFIG_PARAVIRT_XEN) := xen-evtchn
 xen-privcmd_$(CONFIG_PARAVIRT_XEN) := xen-privcmd.o
 
+ifneq ($(CONFIG_ARM),y)
+obj-$(CONFIG_PARAVIRT_XEN)	+= manage.o balloon.o
+obj-$(CONFIG_HOTPLUG_CPU)	+= $(xen-hotplug-y)
+endif
+obj-$(CONFIG_X86)		+= fallback.o
+obj-$(CONFIG_PARAVIRT_XEN)	+= grant-table.o features.o events.o
+
 xen-balloon_$(CONFIG_XEN)	:= balloon/
 xen-privcmd_$(CONFIG_XEN)	:= privcmd/
 obj-$(CONFIG_XEN)		+= core/
@@ -25,8 +31,12 @@ priv-$(CONFIG_PCI)			+= pci.o
 
 obj-$(CONFIG_XEN)			+= features.o $(xen-backend-y) $(xen-backend-m)
 obj-$(CONFIG_XEN_PRIVILEGED_GUEST)	+= $(priv-y)
+dom0-$(CONFIG_PCI) += pci.o
+dom0-$(CONFIG_USB_SUPPORT) += dbgp.o
+dom0-$(CONFIG_ACPI) += acpi.o
+dom0-$(CONFIG_X86) += pcpu.o
+obj-$(CONFIG_XEN_DOM0)			+= $(dom0-y)
 obj-$(CONFIG_BLOCK)			+= $(xen-biomerge-y)
-obj-$(CONFIG_HOTPLUG_CPU)		+= $(xen-hotplug-y)
 obj-$(CONFIG_XEN_XENCOMM)		+= xencomm.o
 obj-$(CONFIG_XEN_BALLOON)		+= $(xen-balloon_y)
 obj-$(CONFIG_XEN_SELFBALLOONING)	+= xen-selfballoon.o
@@ -38,8 +48,6 @@ obj-$(CONFIG_XEN_SYS_HYPERVISOR)	+= sys-
 obj-$(CONFIG_XEN_PVHVM)			+= platform-pci.o
 obj-$(CONFIG_XEN_TMEM)			+= tmem.o
 obj-$(CONFIG_SWIOTLB_XEN)		+= swiotlb-xen.o
-obj-$(CONFIG_XEN_DOM0)			+= pcpu.o
-obj-$(CONFIG_XEN_DOM0)			+= pci.o acpi.o
 obj-$(CONFIG_XEN_MCE_LOG)		+= mcelog.o
 obj-$(CONFIG_XEN_PCIDEV_BACKEND)	+= xen-pciback/
 obj-$(CONFIG_XEN_PRIVCMD)		+= $(xen-privcmd_y)
--- 12.3.orig/drivers/xen/blkfront/blkfront.c	2012-08-20 16:16:44.000000000 +0200
+++ 12.3/drivers/xen/blkfront/blkfront.c	2012-10-30 15:57:12.000000000 +0100
@@ -497,7 +497,7 @@ static void blkfront_closing(struct blkf
 	spin_unlock_irqrestore(&info->io_lock, flags);
 
 	/* Flush gnttab callback work. Must be done with no locks held. */
-	flush_work_sync(&info->work);
+	flush_work(&info->work);
 
 	xlvbd_sysfs_delif(info);
 
@@ -1091,7 +1091,7 @@ static void blkif_free(struct blkfront_i
 	spin_unlock_irq(&info->io_lock);
 
 	/* Flush gnttab callback work. Must be done with no locks held. */
-	flush_work_sync(&info->work);
+	flush_work(&info->work);
 
 	/* Free resources associated with old device channel. */
 	if (info->ring_ref != GRANT_INVALID_REF) {
--- 12.3.orig/drivers/xen/blktap/blktap.c	2013-01-25 15:09:14.000000000 +0100
+++ 12.3/drivers/xen/blktap/blktap.c	2013-06-24 16:50:31.000000000 +0200
@@ -719,7 +719,7 @@ static int blktap_mmap(struct file *filp
 		return -EPERM;
 	}
 
-	vma->vm_flags |= VM_RESERVED;
+	vma->vm_flags |= VM_DONTEXPAND | VM_DONTDUMP;
 	vma->vm_ops = &blktap_vm_ops;
 
 	size = vma->vm_end - vma->vm_start;
--- 12.3.orig/drivers/xen/blktap2-new/ring.c	2011-11-21 15:50:37.000000000 +0100
+++ 12.3/drivers/xen/blktap2-new/ring.c	2012-10-30 14:55:51.000000000 +0100
@@ -352,8 +352,7 @@ blktap_ring_mmap(struct file *filp, stru
 
 	vma->vm_private_data = tap;
 
-	vma->vm_flags |= VM_DONTCOPY;
-	vma->vm_flags |= VM_RESERVED;
+	vma->vm_flags |= VM_DONTCOPY | VM_DONTEXPAND | VM_DONTDUMP;
 
 	vma->vm_ops = &blktap_ring_vm_operations;
 
--- 12.3.orig/drivers/xen/blktap2/ring.c	2011-02-01 15:04:27.000000000 +0100
+++ 12.3/drivers/xen/blktap2/ring.c	2012-10-30 14:56:19.000000000 +0100
@@ -325,9 +325,7 @@ blktap_ring_mmap(struct file *filp, stru
 	/* Mark this VM as containing foreign pages, and set up mappings. */
 	ring->foreign_map.map = map;
 	vma->vm_private_data = &ring->foreign_map;
-	vma->vm_flags |= VM_FOREIGN;
-	vma->vm_flags |= VM_DONTCOPY;
-	vma->vm_flags |= VM_RESERVED;
+	vma->vm_flags |= VM_FOREIGN | VM_DONTCOPY | VM_DONTEXPAND | VM_DONTDUMP;
 	vma->vm_ops = &blktap_ring_vm_operations;
 
 #ifdef CONFIG_X86
--- 12.3.orig/drivers/xen/console/console.c	2013-02-05 10:54:40.000000000 +0100
+++ 12.3/drivers/xen/console/console.c	2013-07-17 17:38:50.000000000 +0200
@@ -340,10 +340,13 @@ void __init dom0_init_screen_info(const 
 #define DUMMY_TTY(_tty) ((xc_mode == XC_TTY) &&		\
 			 ((_tty)->index != (xc_num - 1)))
 
+static struct tty_port *xencons_ports;
 static struct tty_struct *xencons_tty;
 static int xencons_priv_irq;
 static char x_char;
 
+static const struct tty_port_operations xencons_port_ops = {};
+
 void xencons_rx(char *buf, unsigned len)
 {
 	int           i;
@@ -579,6 +582,22 @@ static void xencons_wait_until_sent(stru
 	set_current_state(TASK_RUNNING);
 }
 
+static int xencons_install(struct tty_driver *drv, struct tty_struct *tty)
+{
+	struct tty_port *port = &xencons_ports[tty->index];
+	int rc;
+
+	tty->driver_data = NULL;
+
+	tty_port_init(port);
+	port->ops = &xencons_port_ops;
+
+	rc = tty_port_install(port, drv, tty);
+	if (rc)
+		tty_port_put(port);
+	return rc;
+}
+
 static int xencons_open(struct tty_struct *tty, struct file *filp)
 {
 	unsigned long flags;
@@ -587,7 +606,6 @@ static int xencons_open(struct tty_struc
 		return 0;
 
 	spin_lock_irqsave(&xencons_lock, flags);
-	tty->driver_data = NULL;
 	if (xencons_tty == NULL)
 		xencons_tty = tty;
 	__xencons_tx_flush();
@@ -608,9 +626,9 @@ static void xencons_close(struct tty_str
 	 * (__tty_hangup) or don't care as they drop the lock right after our
 	 * return (tty_release) in order to then acquire both in proper order.
 	 */
-	tty_unlock();
+	tty_unlock(tty);
 	mutex_lock(&tty_mutex);
-	tty_lock();
+	tty_lock(tty);
 
 	if (tty->count != 1) {
 		mutex_unlock(&tty_mutex);
@@ -633,6 +651,7 @@ static void xencons_close(struct tty_str
 }
 
 static const struct tty_operations xencons_ops = {
+	.install = xencons_install,
 	.open = xencons_open,
 	.close = xencons_close,
 	.write = xencons_write,
@@ -663,10 +682,16 @@ static int __init xencons_init(void)
 			return rc;
 	}
 
-	xencons_driver = alloc_tty_driver((xc_mode == XC_TTY) ?
-					  MAX_NR_CONSOLES : 1);
-	if (xencons_driver == NULL)
+	rc = xc_mode == XC_TTY ? MAX_NR_CONSOLES : 1;
+	xencons_ports = kcalloc(rc, sizeof(*xencons_ports), GFP_KERNEL);
+	if (!xencons_ports)
+		return -ENOMEM;
+	xencons_driver = alloc_tty_driver(rc);
+	if (!xencons_driver) {
+		kfree(xencons_ports);
+		xencons_ports = NULL;
 		return -ENOMEM;
+	}
 
 	DRV(xencons_driver)->name            = "xencons";
 	DRV(xencons_driver)->major           = TTY_MAJOR;
@@ -711,6 +736,8 @@ static int __init xencons_init(void)
 			   DRV(xencons_driver)->name_base);
 		put_tty_driver(xencons_driver);
 		xencons_driver = NULL;
+		kfree(xencons_ports);
+		xencons_ports = NULL;
 		return rc;
 	}
 
--- 12.3.orig/drivers/xen/core/Makefile	2012-02-17 14:35:00.000000000 +0100
+++ 12.3/drivers/xen/core/Makefile	2012-11-14 14:29:01.000000000 +0100
@@ -2,7 +2,7 @@
 # Makefile for the linux kernel.
 #
 
-obj-y := evtchn.o gnttab.o reboot.o machine_reboot.o fallback.o
+obj-y := evtchn.o gnttab.o reboot.o machine_reboot.o
 
 obj-$(CONFIG_XEN_PRIVILEGED_GUEST) += firmware.o
 obj-$(CONFIG_PROC_FS)		+= xen_proc.o
--- 12.3.orig/drivers/xen/core/reboot.c	2011-11-18 15:46:15.000000000 +0100
+++ 12.3/drivers/xen/core/reboot.c	2012-11-05 12:27:07.000000000 +0100
@@ -1,6 +1,7 @@
 #include <linux/kernel.h>
 #include <linux/unistd.h>
 #include <linux/init.h>
+#include <linux/kthread.h>
 #include <linux/slab.h>
 #include <linux/reboot.h>
 #include <linux/sched.h>
@@ -148,15 +149,15 @@ static void switch_shutdown_state(int ne
 
 static void __shutdown_handler(struct work_struct *unused)
 {
-	int err;
+	struct task_struct *taskp;
 
-	err = kernel_thread((shutting_down == SHUTDOWN_SUSPEND) ?
+	taskp = kthread_run((shutting_down == SHUTDOWN_SUSPEND) ?
 			    xen_suspend : shutdown_process,
-			    NULL, CLONE_FS | CLONE_FILES);
+			    NULL, "shutdown");
 
-	if (err < 0) {
-		pr_warning("Error creating shutdown process (%d): "
-			   "retrying...\n", -err);
+	if (IS_ERR(taskp)) {
+		pr_warning("Error creating shutdown process (%ld): "
+			   "retrying...\n", -PTR_ERR(taskp));
 		schedule_delayed_work(&shutdown_work, HZ/2);
 	}
 }
--- 12.3.orig/drivers/xen/core/smpboot.c	2012-09-05 16:52:20.000000000 +0200
+++ 12.3/drivers/xen/core/smpboot.c	2012-10-31 16:30:47.000000000 +0100
@@ -363,9 +363,6 @@ void __cpuinit __cpu_die(unsigned int cp
 	}
 
 	xen_smp_intr_exit(cpu);
-
-	if (num_online_cpus() == 1)
-		alternatives_smp_switch(0);
 }
 
 #endif /* CONFIG_HOTPLUG_CPU */
@@ -392,7 +389,7 @@ int __cpuinit __cpu_up(unsigned int cpu,
 	cpu_initialize_context(cpu, idle->thread.sp0);
 
 	if (num_online_cpus() == 1)
-		alternatives_smp_switch(1);
+		alternatives_enable_smp();
 
 	/* This must be done before setting cpu_online_map */
 	wmb();
@@ -410,11 +407,8 @@ int __cpuinit __cpu_up(unsigned int cpu,
 		}
 	}
 
-	if (rc) {
+	if (rc)
 		xen_smp_intr_exit(cpu);
-		if (num_online_cpus() == 1)
-			alternatives_smp_switch(0);
-	}
 
 	return rc;
 }
--- 12.3.orig/drivers/xen/fallback.c	2013-11-27 11:08:55.000000000 +0100
+++ 12.3/drivers/xen/fallback.c	2012-11-14 13:29:46.000000000 +0100
@@ -3,7 +3,16 @@
 #include <linux/bug.h>
 #include <linux/export.h>
 #include <asm/hypervisor.h>
+#ifdef CONFIG_PARAVIRT_XEN
 #include <asm/xen/hypercall.h>
+#else
+#define xen_event_channel_op_compat HYPERVISOR_event_channel_op_compat
+#endif
+
+#if defined(CONFIG_PARAVIRT_XEN) || CONFIG_XEN_COMPAT <= 0x030002
+
+#include <xen/interface/event_channel.h>
+#include <xen/interface/physdev.h>
 
 int xen_event_channel_op_compat(int cmd, void *arg)
 {
@@ -78,3 +87,5 @@ int HYPERVISOR_physdev_op_compat(int cmd
 
 	return rc;
 }
+
+#endif /* CONFIG_XEN_COMPAT <= 0x030002 */
--- 12.3.orig/drivers/xen/fbfront/xenfb.c	2011-02-08 10:37:50.000000000 +0100
+++ 12.3/drivers/xen/fbfront/xenfb.c	2012-10-30 14:53:54.000000000 +0100
@@ -457,7 +457,7 @@ static int xenfb_mmap(struct fb_info *fb
 	mutex_unlock(&info->mm_lock);
 
 	vma->vm_ops = &xenfb_vm_ops;
-	vma->vm_flags |= (VM_DONTEXPAND | VM_RESERVED);
+	vma->vm_flags |= VM_DONTEXPAND | VM_DONTDUMP;
 	vma->vm_private_data = map;
 
 	return 0;
--- 12.3.orig/drivers/xen/gntdev/gntdev.c	2011-09-09 09:39:43.000000000 +0200
+++ 12.3/drivers/xen/gntdev/gntdev.c	2012-10-30 14:55:28.000000000 +0100
@@ -514,7 +514,7 @@ static int gntdev_mmap (struct file *fli
 	vma->vm_flags |= VM_FOREIGN;
 
 	/* This flag prevents Bad PTE errors when the memory is unmapped. */
-	vma->vm_flags |= VM_RESERVED;
+	vma->vm_flags |= VM_DONTEXPAND | VM_DONTDUMP;
 
 	/* This flag prevents this VM area being copied on a fork(). A better
 	 * behaviour might be to explicitly carry out the appropriate mappings
--- 12.3.orig/drivers/xen/netback/netback.c	2013-06-24 12:44:29.000000000 +0200
+++ 12.3/drivers/xen/netback/netback.c	2013-08-20 13:06:13.000000000 +0200
@@ -36,6 +36,7 @@
 
 #include "common.h"
 #include <linux/if_vlan.h>
+#include <linux/pfn.h>
 #include <net/tcp.h>
 #include <xen/balloon.h>
 #include <xen/evtchn.h>
@@ -48,9 +49,16 @@
 struct netbk_rx_meta {
 	skb_frag_t frag;
 	int id;
-	u8 copy:1;
+	u8 copy:2;
+	u8 tail:1;
 };
 
+struct netbk_rx_cb {
+	unsigned int nr_frags;
+	unsigned int nr_slots;
+};
+#define netbk_rx_cb(skb) ((struct netbk_rx_cb *)skb->cb)
+
 struct netbk_tx_cb {
 	u16 copy_slots;
 	u16 pending_idx[1 + XEN_NETIF_NR_SLOTS_MIN];
@@ -301,14 +309,15 @@ static struct sk_buff *netbk_copy_skb(st
 	return NULL;
 }
 
-static inline int netbk_max_required_rx_slots(netif_t *netif)
+static inline unsigned int netbk_max_required_rx_slots(const netif_t *netif)
 {
-	if (netif->can_sg || netif->gso)
-		return MAX_SKB_FRAGS + 2; /* header + extra_info + frags */
-	return 1; /* all in one */
+	return netif->can_sg || netif->gso
+	       ? max_t(unsigned int, XEN_NETIF_NR_SLOTS_MIN,
+		       MAX_SKB_FRAGS + 2/* header + extra_info + frags */)
+	       : 1; /* all in one */
 }
 
-static inline int netbk_queue_full(netif_t *netif)
+static inline bool netbk_queue_full(const netif_t *netif)
 {
 	RING_IDX peek   = netif->rx_req_cons_peek;
 	RING_IDX needed = netbk_max_required_rx_slots(netif);
@@ -324,6 +333,24 @@ static void tx_queue_callback(unsigned l
 		netif_wake_queue(netif->dev);
 }
 
+static unsigned int netbk_count_slots(const struct skb_shared_info *shinfo,
+				      bool copying)
+{
+	unsigned int i, slots;
+
+	for (slots = i = 0; i < shinfo->nr_frags; ++i) {
+		const skb_frag_t *frag = shinfo->frags + i;
+		unsigned int len = skb_frag_size(frag), offs;
+
+		if (!len)
+			continue;
+		offs = copying ? 0 : offset_in_page(frag->page_offset);
+		slots += PFN_UP(offs + len);
+	}
+
+	return slots;
+}
+
 int netif_be_start_xmit(struct sk_buff *skb, struct net_device *dev)
 {
 	netif_t *netif = netdev_priv(dev);
@@ -352,8 +379,10 @@ int netif_be_start_xmit(struct sk_buff *
 		skb = nskb;
 	}
 
-	netif->rx_req_cons_peek += skb_shinfo(skb)->nr_frags + 1 +
-				   !!skb_shinfo(skb)->gso_size;
+	netbk_rx_cb(skb)->nr_slots = 1 + !!skb_shinfo(skb)->gso_size +
+				     netbk_count_slots(skb_shinfo(skb),
+						       netif->copying_receiver);
+	netif->rx_req_cons_peek += netbk_rx_cb(skb)->nr_slots;
 	netif_get(netif);
 
 	if (netbk_can_queue(dev) && netbk_queue_full(netif)) {
@@ -420,10 +449,11 @@ struct netrx_pending_operations {
 
 /* Set up the grant operations for this fragment.  If it's a flipping
    interface, we also set up the unmap request from here. */
-static u16 netbk_gop_frag(netif_t *netif, struct netbk_rx_meta *meta,
-			  int i, struct netrx_pending_operations *npo,
-			  struct page *page, unsigned long size,
-			  unsigned long offset)
+static void netbk_gop_frag(netif_t *netif, struct netbk_rx_meta *meta,
+			   unsigned int i,
+			   struct netrx_pending_operations *npo,
+			   struct page *page, unsigned int size,
+			   unsigned int offset)
 {
 	mmu_update_t *mmu;
 	gnttab_transfer_t *gop;
@@ -439,7 +469,7 @@ static u16 netbk_gop_frag(netif_t *netif
 	if (netif->copying_receiver) {
 		/* The fragment needs to be copied rather than
 		   flipped. */
-		meta->copy = 1;
+		meta->copy++;
 		copy_gop = npo->copy + npo->copy_prod++;
 		copy_gop->flags = GNTCOPY_dest_gref;
 		if (idx > -1) {
@@ -453,11 +483,10 @@ static u16 netbk_gop_frag(netif_t *netif
 		}
 		copy_gop->source.offset = offset;
 		copy_gop->dest.domid = netif->domid;
-		copy_gop->dest.offset = 0;
+		copy_gop->dest.offset = i ? meta->frag.size : 0;
 		copy_gop->dest.u.ref = req->gref;
 		copy_gop->len = size;
 	} else {
-		meta->copy = 0;
 		if (!xen_feature(XENFEAT_auto_translated_physmap)) {
 			new_mfn = alloc_mfn();
 
@@ -485,7 +514,7 @@ static u16 netbk_gop_frag(netif_t *netif
 		gop->domid = netif->domid;
 		gop->ref = req->gref;
 	}
-	return req->id;
+	meta->id = req->id;
 }
 
 static void netbk_gop_skb(struct sk_buff *skb,
@@ -493,22 +522,63 @@ static void netbk_gop_skb(struct sk_buff
 {
 	netif_t *netif = netdev_priv(skb->dev);
 	int nr_frags = skb_shinfo(skb)->nr_frags;
-	int i;
-	int extra;
+	unsigned int i, n;
 	struct netbk_rx_meta *head_meta, *meta;
 
 	head_meta = npo->meta + npo->meta_prod++;
 	head_meta->frag.page_offset = skb_shinfo(skb)->gso_type;
 	head_meta->frag.size = skb_shinfo(skb)->gso_size;
-	extra = !!head_meta->frag.size + 1;
+	head_meta->copy = 0;
+	n = !!head_meta->frag.size + 1;
 
-	for (i = 0; i < nr_frags; i++) {
-		meta = npo->meta + npo->meta_prod++;
-		meta->frag = skb_shinfo(skb)->frags[i];
-		meta->id = netbk_gop_frag(netif, meta, i + extra, npo,
-					  skb_frag_page(&meta->frag),
-					  skb_frag_size(&meta->frag),
-					  meta->frag.page_offset);
+	for (i = 0; i < nr_frags; i++, n++) {
+		const skb_frag_t *frag = skb_shinfo(skb)->frags + i;
+		unsigned int offset = frag->page_offset;
+		unsigned int len = skb_frag_size(frag);
+		struct page *frag_page = skb_frag_page(frag);
+		struct page *page = frag_page + PFN_DOWN(offset);
+
+		if (!len)
+			continue;
+		for (meta = NULL, offset &= ~PAGE_MASK; len; ) {
+			unsigned int bytes = PAGE_SIZE - offset;
+
+			if (bytes > len)
+				bytes = len;
+			/*
+			 * Try to reduce the number of slots needed (at the
+			 * expense of more copy operations), so that frontends
+			 * only coping with the minimum slot count required to
+			 * be supported have a better chance of receiving this
+			 * packet.
+			 */
+			else if (meta && meta->copy &&
+				 (bytes > PAGE_SIZE - meta->frag.size) &&
+				 (offset_in_page(len) + meta->frag.size <=
+				  PAGE_SIZE))
+				bytes = PAGE_SIZE - meta->frag.size;
+			if (!meta || !meta->copy ||
+			    bytes > PAGE_SIZE - meta->frag.size) {
+				if (meta)
+					n++;
+				meta = npo->meta + npo->meta_prod++;
+				__skb_frag_set_page(&meta->frag, frag_page);
+				frag_page = NULL;
+				meta->frag.page_offset = offset;
+				meta->frag.size = 0;
+				meta->copy = 0;
+				meta->tail = 0;
+			}
+			netbk_gop_frag(netif, meta, n, npo, page, bytes,
+				       offset);
+			meta->frag.size += bytes;
+			len -= bytes;
+			if ((offset += bytes) == PAGE_SIZE) {
+				++page;
+				offset = 0;
+			}
+		}
+		meta->tail = 1;
 	}
 
 	/*
@@ -516,20 +586,25 @@ static void netbk_gop_skb(struct sk_buff
 	 * until we're done. We know that the head doesn't cross a page
 	 * boundary because such packets get copied in netif_be_start_xmit.
 	 */
-	head_meta->id = netbk_gop_frag(netif, head_meta, 0, npo,
-				       virt_to_page(skb->data),
-				       skb_headlen(skb),
-				       offset_in_page(skb->data));
+	netbk_gop_frag(netif, head_meta, 0, npo, virt_to_page(skb->data),
+		       skb_headlen(skb), offset_in_page(skb->data));
+	head_meta->tail = 1;
 
-	netif->rx.req_cons += nr_frags + extra;
+	netif->rx.req_cons += n;
 }
 
 static inline void netbk_free_pages(int nr_frags, struct netbk_rx_meta *meta)
 {
 	int i;
 
-	for (i = 0; i < nr_frags; i++)
-		put_page(skb_frag_page(&meta[i].frag));
+	for (i = 0; i < nr_frags; meta++) {
+		struct page *page = skb_frag_page(&meta->frag);
+
+		if (page) {
+			put_page(page);
+			i++;
+		}
+	}
 }
 
 /* This is a twin to netbk_gop_skb.  Assume that netbk_gop_skb was
@@ -543,17 +618,22 @@ static int netbk_check_gop(int nr_frags,
 	gnttab_copy_t     *copy_op;
 	int status = XEN_NETIF_RSP_OKAY;
 	int i;
+	const struct netbk_rx_meta *meta = npo->meta + npo->meta_cons;
 
-	for (i = 0; i <= nr_frags; i++) {
-		if (npo->meta[npo->meta_cons + i].copy) {
-			copy_op = npo->copy + npo->copy_cons++;
-			if (unlikely(copy_op->status == GNTST_eagain))
-				gnttab_check_GNTST_eagain_while(GNTTABOP_copy, copy_op);
-			if (unlikely(copy_op->status != GNTST_okay)) {
-				DPRINTK("Bad status %d from copy to DOM%d.\n",
-					copy_op->status, domid);
-				status = XEN_NETIF_RSP_ERROR;
-			}
+	for (i = 0; i <= nr_frags; i += meta++->tail) {
+		unsigned int copy = meta->copy;
+
+		if (copy) {
+			do {
+				copy_op = npo->copy + npo->copy_cons++;
+				if (unlikely(copy_op->status == GNTST_eagain))
+					gnttab_check_GNTST_eagain_while(GNTTABOP_copy, copy_op);
+				if (unlikely(copy_op->status != GNTST_okay)) {
+					DPRINTK("Bad status %d from copy to DOM%d.\n",
+						copy_op->status, domid);
+					status = XEN_NETIF_RSP_ERROR;
+				}
+			} while (--copy);
 		} else {
 			if (!xen_feature(XENFEAT_auto_translated_physmap)) {
 				mcl = npo->mcl + npo->mcl_cons++;
@@ -580,23 +660,22 @@ static int netbk_check_gop(int nr_frags,
 	return status;
 }
 
-static void netbk_add_frag_responses(netif_t *netif, int status,
-				     struct netbk_rx_meta *meta, int nr_frags)
+static unsigned int netbk_add_frag_responses(netif_t *netif, int status,
+					     const struct netbk_rx_meta *meta,
+					     unsigned int nr_frags)
 {
-	int i;
-	unsigned long offset;
+	unsigned int i, n;
 
-	for (i = 0; i < nr_frags; i++) {
-		int id = meta[i].id;
-		int flags = (i == nr_frags - 1) ? 0 : XEN_NETRXF_more_data;
+	for (n = i = 0; i < nr_frags; meta++, n++) {
+		int flags = (meta->tail && ++i == nr_frags)
+			    ? 0 : XEN_NETRXF_more_data;
 
-		if (meta[i].copy)
-			offset = 0;
-		else
-			offset = meta[i].frag.page_offset;
-		make_rx_response(netif, id, status, offset,
-				 meta[i].frag.size, flags);
+		make_rx_response(netif, meta->id, status,
+				 meta->copy ? 0 : meta->frag.page_offset,
+				 meta->frag.size, flags);
 	}
+
+	return n;
 }
 
 static void net_rx_action(unsigned long unused)
@@ -621,7 +700,7 @@ static void net_rx_action(unsigned long 
 	static multicall_entry_t rx_mcl[NET_RX_RING_SIZE+3];
 	static mmu_update_t rx_mmu[NET_RX_RING_SIZE];
 	static gnttab_transfer_t grant_trans_op[NET_RX_RING_SIZE];
-	static gnttab_copy_t grant_copy_op[NET_RX_RING_SIZE];
+	static gnttab_copy_t grant_copy_op[2 * NET_RX_RING_SIZE];
 	static unsigned char rx_notify[NR_IRQS];
 	static u16 notify_list[NET_RX_RING_SIZE];
 	static struct netbk_rx_meta meta[NET_RX_RING_SIZE];
@@ -633,17 +712,25 @@ static void net_rx_action(unsigned long 
 		mcl: rx_mcl,
 		meta: meta};
 
+	BUILD_BUG_ON(sizeof(skb->cb) < sizeof(struct netbk_rx_cb));
+
 	skb_queue_head_init(&rxq);
 
 	count = 0;
 
 	while ((skb = skb_dequeue(&rx_queue)) != NULL) {
-		nr_frags = skb_shinfo(skb)->nr_frags;
-		*(int *)skb->cb = nr_frags;
+		netbk_rx_cb(skb)->nr_frags = skb_shinfo(skb)->nr_frags;
+		nr_frags = netbk_rx_cb(skb)->nr_slots;
+
+		/* Filled the batch queue? */
+		if (count + nr_frags > NET_RX_RING_SIZE) {
+			skb_queue_head(&rx_queue, skb);
+			break;
+		}
 
 		if (!xen_feature(XENFEAT_auto_translated_physmap) &&
 		    !((netif_t *)netdev_priv(skb->dev))->copying_receiver &&
-		    check_mfn(nr_frags + 1)) {
+		    check_mfn(nr_frags)) {
 			/* Memory squeeze? Back off for an arbitrary while. */
 			if ( net_ratelimit() )
 				WPRINTK("Memory squeeze in netback "
@@ -655,13 +742,9 @@ static void net_rx_action(unsigned long 
 
 		netbk_gop_skb(skb, &npo);
 
-		count += nr_frags + 1;
+		count += nr_frags;
 
 		__skb_queue_tail(&rxq, skb);
-
-		/* Filled the batch queue? */
-		if (count + MAX_SKB_FRAGS >= NET_RX_RING_SIZE)
-			break;
 	}
 
 	BUG_ON(npo.meta_prod > ARRAY_SIZE(meta));
@@ -704,7 +787,7 @@ static void net_rx_action(unsigned long 
 	BUG_ON(npo.mmu_mcl && npo.mcl[npo.mmu_mcl].result != 0);
 
 	while ((skb = __skb_dequeue(&rxq)) != NULL) {
-		nr_frags = *(int *)skb->cb;
+		nr_frags = netbk_rx_cb(skb)->nr_frags;
 
 		netif = netdev_priv(skb->dev);
 
@@ -765,9 +848,9 @@ static void net_rx_action(unsigned long 
 			gso->flags = 0;
 		}
 
-		netbk_add_frag_responses(netif, status,
-					 meta + npo.meta_cons + 1,
-					 nr_frags);
+		nr_frags = netbk_add_frag_responses(netif, status,
+						    meta + npo.meta_cons + 1,
+						    nr_frags);
 
 		RING_PUSH_RESPONSES_AND_CHECK_NOTIFY(&netif->rx, ret);
 		irq = netif->irq;
@@ -1215,9 +1298,10 @@ void netbk_get_requests(netif_t *netif, 
 		frag_set_pending_idx(&frags[i], pending_idx);
 	}
 
-	if ((void *)gop->map > (void *)gop->copy && net_ratelimit())
-		netdev_warn(netif->dev, "Grant op overrun (%p > %p)\n",
-			    gop->map, gop->copy);
+	if ((void *)gop->map > (void *)gop->copy)
+		net_warn_ratelimited("%s: Grant op overrun (%p > %p)\n",
+				     netdev_name(netif->dev),
+				     gop->map, gop->copy);
 }
 
 static int netbk_tx_check_gop(struct sk_buff *skb,
@@ -1316,9 +1400,9 @@ static int netbk_tx_check_gop(struct sk_
 
 	gop->map = mop;
 	gop->copy = cop;
-	if ((void *)mop > (void *)cop && net_ratelimit())
-		netdev_warn(netif->dev, "Grant op check overrun (%p > %p)\n",
-			    mop, cop);
+	if ((void *)mop > (void *)cop)
+		net_warn_ratelimited("%s: Grant op check overrun (%p > %p)\n",
+				     netdev_name(netif->dev), mop, cop);
 	return err;
 }
 
--- 12.3.orig/drivers/xen/netfront/netfront.c	2013-07-15 12:33:17.000000000 +0200
+++ 12.3/drivers/xen/netfront/netfront.c	2013-08-08 14:18:44.000000000 +0200
@@ -574,7 +574,7 @@ static void backend_changed(struct xenbu
 		break;
 
 	case XenbusStateConnected:
-		netif_notify_peers(netdev);
+		netdev_notify_peers(netdev);
 		break;
 
 	case XenbusStateClosed:
@@ -904,29 +904,68 @@ static void xennet_make_frags(struct sk_
 
 	for (i = 0; i < frags; i++) {
 		skb_frag_t *frag = skb_shinfo(skb)->frags + i;
+		struct page *page = skb_frag_page(frag);
 
-		tx->flags |= XEN_NETTXF_more_data;
+		len = skb_frag_size(frag);
+		offset = frag->page_offset;
 
-		id = get_id_from_freelist(np->tx_skbs);
-		np->tx_skbs[id] = skb_get(skb);
-		tx = RING_GET_REQUEST(&np->tx, prod++);
-		tx->id = id;
-		ref = gnttab_claim_grant_reference(&np->gref_tx_head);
-		BUG_ON((signed short)ref < 0);
+		/* Data must not cross a page boundary. */
+		BUG_ON(offset + len > (PAGE_SIZE << compound_order(page)));
 
-		mfn = pfn_to_mfn(page_to_pfn(skb_frag_page(frag)));
-		gnttab_grant_foreign_access_ref(ref, np->xbdev->otherend_id,
-						mfn, GTF_readonly);
+		/* Skip unused frames from start of page */
+		page += PFN_DOWN(offset);
+		for (offset &= ~PAGE_MASK; len; page++, offset = 0) {
+			unsigned int bytes = PAGE_SIZE - offset;
 
-		tx->gref = np->grant_tx_ref[id] = ref;
-		tx->offset = frag->page_offset;
-		tx->size = skb_frag_size(frag);
-		tx->flags = 0;
+			if (bytes > len)
+				bytes = len;
+
+			tx->flags |= XEN_NETTXF_more_data;
+
+			id = get_id_from_freelist(np->tx_skbs);
+			np->tx_skbs[id] = skb_get(skb);
+			tx = RING_GET_REQUEST(&np->tx, prod++);
+			tx->id = id;
+			ref = gnttab_claim_grant_reference(&np->gref_tx_head);
+			BUG_ON((signed short)ref < 0);
+
+			mfn = pfn_to_mfn(page_to_pfn(page));
+			gnttab_grant_foreign_access_ref(ref,
+							np->xbdev->otherend_id,
+							mfn, GTF_readonly);
+
+			tx->gref = np->grant_tx_ref[id] = ref;
+			tx->offset = offset;
+			tx->size = bytes;
+			tx->flags = 0;
+
+			len -= bytes;
+		}
 	}
 
 	np->tx.req_prod_pvt = prod;
 }
 
+/*
+ * Count how many ring slots are required to send the frags of this
+ * skb. Each frag might be a compound page.
+ */
+static unsigned int xennet_count_skb_frag_slots(const struct sk_buff *skb)
+{
+	unsigned int i, pages, frags = skb_shinfo(skb)->nr_frags;
+
+	for (pages = i = 0; i < frags; i++) {
+		const skb_frag_t *frag = skb_shinfo(skb)->frags + i;
+		unsigned int len = skb_frag_size(frag);
+
+		if (!len)
+			continue;
+		pages += PFN_UP((frag->page_offset & ~PAGE_MASK) + len);
+	}
+
+	return pages;
+}
+
 static int network_start_xmit(struct sk_buff *skb, struct net_device *dev)
 {
 	unsigned short id;
@@ -939,9 +978,8 @@ static int network_start_xmit(struct sk_
 	grant_ref_t ref;
 	unsigned long mfn, flags;
 	int notify;
-	int frags = skb_shinfo(skb)->nr_frags;
 	unsigned int offset = offset_in_page(data);
-	unsigned int len = skb_headlen(skb);
+	unsigned int slots, len = skb_headlen(skb);
 
 	/* Check the fast path, if hooks are available */
  	if (np->accel_vif_state.hooks && 
@@ -960,17 +998,17 @@ static int network_start_xmit(struct sk_
 		goto drop;
 	}
 
-	frags += PFN_UP(offset + len);
-	if (unlikely(frags > MAX_SKB_FRAGS + 1)) {
-		pr_alert("xennet: skb rides the rocket: %d frags\n", frags);
-		dump_stack();
+	slots = PFN_UP(offset + len) + xennet_count_skb_frag_slots(skb);
+	if (unlikely(slots > MAX_SKB_FRAGS + 1)) {
+		net_alert_ratelimited("xennet: skb rides the rocket: %u slots\n",
+				      slots);
 		goto drop;
 	}
 
 	spin_lock_irqsave(&np->tx_lock, flags);
 
 	if (unlikely(!netfront_carrier_ok(np) ||
-		     (frags > 1 && !xennet_can_sg(dev)) ||
+		     (slots > 1 && !xennet_can_sg(dev)) ||
 		     netif_needs_gso(skb, netif_skb_features(skb)))) {
 		spin_unlock_irqrestore(&np->tx_lock, flags);
 		goto drop;
--- 12.3.orig/drivers/xen/pcifront/xenbus.c	2012-08-20 16:17:15.000000000 +0200
+++ 12.3/drivers/xen/pcifront/xenbus.c	2012-10-30 17:25:04.000000000 +0100
@@ -60,7 +60,7 @@ static void free_pdev(struct pcifront_de
 	pcifront_free_roots(pdev);
 
 	/*For PCIE_AER error handling job*/
-	flush_work_sync(&pdev->op_work);
+	flush_work(&pdev->op_work);
 
 	if (pdev->irq > 0)
 		unbind_from_irqhandler(pdev->irq, pdev);
@@ -309,7 +309,6 @@ static int pcifront_detach_devices(struc
 	int err = 0;
 	int i, num_devs;
 	unsigned int domain, bus, slot, func;
-	struct pci_bus *pci_bus;
 	struct pci_dev *pci_dev;
 	char str[64];
 
@@ -361,13 +360,8 @@ static int pcifront_detach_devices(struc
 			goto out;
 		}
 
-		pci_bus = pci_find_bus(domain, bus);
-		if(!pci_bus) {
-			dev_dbg(&pdev->xdev->dev, "Cannot get bus %04x:%02x\n",
-				domain, bus);
-			continue;
-		}
-		pci_dev = pci_get_slot(pci_bus, PCI_DEVFN(slot, func));
+		pci_dev = pci_get_domain_bus_and_slot(domain, bus,
+						      PCI_DEVFN(slot, func));
 		if(!pci_dev) {
 			dev_dbg(&pdev->xdev->dev,
 				"Cannot get PCI device %04x:%02x:%02x.%u\n",
--- 12.3.orig/drivers/xen/privcmd/privcmd.c	2012-01-20 15:05:37.000000000 +0100
+++ 12.3/drivers/xen/privcmd/privcmd.c	2012-10-30 17:31:28.000000000 +0100
@@ -255,11 +255,11 @@ static long privcmd_ioctl(struct file *f
 				if(rc < 0) {
 					if (rc == -ENOENT)
 					{
-						*mfn |= 0x80000000U;
+						*mfn |= PRIVCMD_MMAPBATCH_PAGED_ERROR;
 						paged_out = 1;
 					}
 					else
-						*mfn |= 0xf0000000U;
+						*mfn |= PRIVCMD_MMAPBATCH_MFN_ERROR;
 					ret++;
 				}
 				mfn++; i++; addr += PAGE_SIZE;
@@ -412,7 +412,8 @@ static int privcmd_mmap(struct file * fi
 
 	/* DONTCOPY is essential for Xen because copy_page_range doesn't know
 	 * how to recreate these mappings */
-	vma->vm_flags |= VM_RESERVED | VM_IO | VM_PFNMAP | VM_DONTCOPY;
+	vma->vm_flags |= VM_IO | VM_PFNMAP | VM_DONTCOPY | VM_DONTEXPAND |
+			 VM_DONTDUMP;
 	vma->vm_ops = &privcmd_vm_ops;
 	vma->vm_private_data = NULL;
 
--- 12.3.orig/drivers/xen/sfc_netback/accel_xenbus.c	2011-02-03 12:38:43.000000000 +0100
+++ 12.3/drivers/xen/sfc_netback/accel_xenbus.c	2012-10-30 15:57:47.000000000 +0100
@@ -701,7 +701,7 @@ fail_config_watch:
 	 * Flush the scheduled work queue before freeing bend to get
 	 * rid of any pending netback_accel_msg_rx_handler()
 	 */
-	flush_work_sync(&bend->handle_msg);
+	flush_work(&bend->handle_msg);
 
 	mutex_lock(&bend->bend_mutex);
 	net_accel_update_state(dev, XenbusStateUnknown);
@@ -781,7 +781,7 @@ int netback_accel_remove(struct xenbus_d
 	 * Flush the scheduled work queue before freeing bend to get
 	 * rid of any pending netback_accel_msg_rx_handler()
 	 */
-	flush_work_sync(&bend->handle_msg);
+	flush_work(&bend->handle_msg);
 
 	mutex_lock(&bend->bend_mutex);
 
--- 12.3.orig/drivers/xen/sys-hypervisor.c	2012-10-31 11:16:11.000000000 +0100
+++ 12.3/drivers/xen/sys-hypervisor.c	2012-10-31 11:26:32.000000000 +0100
@@ -121,6 +121,7 @@ static void xen_sysfs_version_destroy(vo
 
 /* UUID */
 
+#if !defined(CONFIG_XEN) || CONFIG_XEN_COMPAT < 0x030100
 static ssize_t uuid_show_fallback(struct hyp_sysfs_attr *attr, char *buffer)
 {
 	char *vm, *val;
@@ -140,6 +141,9 @@ static ssize_t uuid_show_fallback(struct
 	kfree(val);
 	return ret;
 }
+#else
+# define uuid_show_fallback(attr, buf) ret
+#endif
 
 static ssize_t uuid_show(struct hyp_sysfs_attr *attr, char *buffer)
 {
--- 12.3.orig/drivers/xen/xenbus/xenbus_client.c	2012-04-11 13:26:23.000000000 +0200
+++ 12.3/drivers/xen/xenbus/xenbus_client.c	2012-10-29 17:13:41.000000000 +0100
@@ -504,8 +504,7 @@ static int xenbus_map_ring_valloc_pv(str
 
 	op.host_addr = arbitrary_virt_to_machine(pte).maddr;
 
-	if (HYPERVISOR_grant_table_op(GNTTABOP_map_grant_ref, &op, 1))
-		BUG();
+	gnttab_batch_map(&op, 1);
 
 	if (op.status != GNTST_okay) {
 		free_vm_area(area);
@@ -586,8 +585,7 @@ int xenbus_map_ring(struct xenbus_device
 	gnttab_set_map_op(&op, (unsigned long)vaddr, GNTMAP_host_map, gnt_ref,
 			  dev->otherend_id);
 
-	if (HYPERVISOR_grant_table_op(GNTTABOP_map_grant_ref, &op, 1))
-		BUG();
+	gnttab_batch_map(&op, 1);
 
 	if (op.status != GNTST_okay) {
 		xenbus_dev_fatal(dev, op.status,
--- 12.3.orig/drivers/xen/xenbus/xenbus_comms.c	2012-06-14 11:23:26.000000000 +0200
+++ 12.3/drivers/xen/xenbus/xenbus_comms.c	2012-10-29 17:13:41.000000000 +0100
@@ -270,7 +270,7 @@ int xb_init_comms(void)
 	} else {
 		err = bind_evtchn_to_irqhandler(xen_store_evtchn, wake_waiting,
 						0, "xenbus", &xb_waitq);
-		if (err <= 0) {
+		if (err < 0) {
 			pr_err("XENBUS request irq failed %i\n", err);
 			return err;
 		}
--- 12.3.orig/drivers/xen/xenbus/xenbus_probe.c	2012-03-12 13:55:51.000000000 +0100
+++ 12.3/drivers/xen/xenbus/xenbus_probe.c	2012-10-29 17:13:41.000000000 +0100
@@ -407,8 +407,8 @@ static int cmp_dev(struct device *dev, v
 	return 0;
 }
 
-struct xenbus_device *xenbus_device_find(const char *nodename,
-					 struct bus_type *bus)
+static struct xenbus_device *xenbus_device_find(const char *nodename,
+						struct bus_type *bus)
 {
 	struct xb_find_info info = { .dev = NULL, .nodename = nodename };
 
@@ -1255,6 +1255,12 @@ static int __init xenstored_local_init(v
 	return err;
 }
 
+enum xenstore_init {
+	UNKNOWN,
+	PV,
+	HVM,
+	LOCAL,
+};
 #ifndef MODULE
 static int __init
 #else
@@ -1263,6 +1269,10 @@ int __devinit
 xenbus_init(void)
 {
 	int err = 0;
+#if !defined(CONFIG_XEN) && !defined(MODULE)
+	enum xenstore_init usage = UNKNOWN;
+	uint64_t v = 0;
+#endif
 
 	DPRINTK("");
 
@@ -1332,8 +1342,30 @@ xenbus_init(void)
 #else /* !defined(CONFIG_XEN) && !defined(MODULE) */
 	xenbus_ring_ops_init();
 
-	if (xen_hvm_domain()) {
-		uint64_t v = 0;
+	if (xen_pv_domain())
+		usage = PV;
+	if (xen_hvm_domain())
+		usage = HVM;
+	if (xen_hvm_domain() && xen_initial_domain())
+		usage = LOCAL;
+	if (xen_pv_domain() && !xen_start_info->store_evtchn)
+		usage = LOCAL;
+	if (xen_pv_domain() && xen_start_info->store_evtchn)
+		atomic_set(&xenbus_xsd_state, XENBUS_XSD_FOREIGN_READY);
+
+	switch (usage) {
+	case LOCAL:
+		err = xenstored_local_init();
+		if (err)
+			goto out_error;
+		xen_store_interface = mfn_to_virt(xen_store_mfn);
+		break;
+	case PV:
+		xen_store_evtchn = xen_start_info->store_evtchn;
+		xen_store_mfn = xen_start_info->store_mfn;
+		xen_store_interface = mfn_to_virt(xen_store_mfn);
+		break;
+	case HVM:
 		err = hvm_get_parameter(HVM_PARAM_STORE_EVTCHN, &v);
 		if (err)
 			goto out_error;
@@ -1342,18 +1374,12 @@ xenbus_init(void)
 		if (err)
 			goto out_error;
 		xen_store_mfn = (unsigned long)v;
-		xen_store_interface = ioremap(xen_store_mfn << PAGE_SHIFT, PAGE_SIZE);
-	} else {
-		xen_store_evtchn = xen_start_info->store_evtchn;
-		xen_store_mfn = xen_start_info->store_mfn;
-		if (xen_store_evtchn)
-			atomic_set(&xenbus_xsd_state, XENBUS_XSD_FOREIGN_READY);
-		else {
-			err = xenstored_local_init();
-			if (err)
-				goto out_error;
-		}
-		xen_store_interface = mfn_to_virt(xen_store_mfn);
+		xen_store_interface =
+			ioremap(xen_store_mfn << PAGE_SHIFT, PAGE_SIZE);
+		break;
+	default:
+		pr_warn("Xenstore state unknown\n");
+		break;
 	}
 #endif
 
--- 12.3.orig/drivers/xen/xenbus/xenbus_xs.c	2012-08-20 14:37:06.000000000 +0200
+++ 12.3/drivers/xen/xenbus/xenbus_xs.c	2012-11-05 12:12:27.000000000 +0100
@@ -44,6 +44,9 @@
 #include <linux/rwsem.h>
 #include <linux/module.h>
 #include <linux/mutex.h>
+#ifndef CONFIG_XEN
+#include <asm/xen/hypervisor.h>
+#endif
 #include <xen/xenbus.h>
 #include <xen/xen.h>
 #include "xenbus_comms.h"
@@ -629,16 +632,40 @@ static struct xenbus_watch *find_watch(c
 	return NULL;
 }
 
+/*
+ * Certain older XenBus toolstack cannot handle reading values that are
+ * not populated. Some Xen 3.4 installation are incapable of doing this
+ * so if we are running on anything older than 4 do not attempt to read
+ * control/platform-feature-xs_reset_watches.
+ */
+static inline bool xen_strict_xenbus_quirk(void)
+{
+#if !defined(CONFIG_XEN) && defined(CONFIG_X86)
+	uint32_t eax, ebx, ecx, edx, base;
+
+	base = xen_cpuid_base();
+	cpuid(base + 1, &eax, &ebx, &ecx, &edx);
+
+	if ((eax >> 16) < 4)
+		return true;
+#endif
+	return false;
+
+}
+
 static void xs_reset_watches(void)
 {
 #if defined(CONFIG_PARAVIRT_XEN) || defined(MODULE)
 	int err, supported = 0;
 
 #ifdef CONFIG_PARAVIRT_XEN
-	if (!xen_hvm_domain())
+	if (!xen_hvm_domain() || xen_initial_domain())
 		return;
 #endif
 
+	if (xen_strict_xenbus_quirk())
+		return;
+
 	err = xenbus_scanf(XBT_NIL, "control",
 			   "platform-feature-xs_reset_watches", "%d",
 			   &supported);
--- 12.3.orig/include/uapi/xen/evtchn.h	2013-11-27 11:08:55.000000000 +0100
+++ 12.3/include/uapi/xen/evtchn.h	2012-10-31 16:44:01.000000000 +0100
@@ -1,88 +1 @@
-/******************************************************************************
- * evtchn.h
- *
- * Interface to /dev/xen/evtchn.
- *
- * Copyright (c) 2003-2005, K A Fraser
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version 2
- * as published by the Free Software Foundation; or, when distributed
- * separately from the Linux kernel or incorporated into other
- * software packages, subject to the following license:
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this source file (the "Software"), to deal in the Software without
- * restriction, including without limitation the rights to use, copy, modify,
- * merge, publish, distribute, sublicense, and/or sell copies of the Software,
- * and to permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
- * IN THE SOFTWARE.
- */
-
-#ifndef __LINUX_PUBLIC_EVTCHN_H__
-#define __LINUX_PUBLIC_EVTCHN_H__
-
-/*
- * Bind a fresh port to VIRQ @virq.
- * Return allocated port.
- */
-#define IOCTL_EVTCHN_BIND_VIRQ				\
-	_IOC(_IOC_NONE, 'E', 0, sizeof(struct ioctl_evtchn_bind_virq))
-struct ioctl_evtchn_bind_virq {
-	unsigned int virq;
-};
-
-/*
- * Bind a fresh port to remote <@remote_domain, @remote_port>.
- * Return allocated port.
- */
-#define IOCTL_EVTCHN_BIND_INTERDOMAIN			\
-	_IOC(_IOC_NONE, 'E', 1, sizeof(struct ioctl_evtchn_bind_interdomain))
-struct ioctl_evtchn_bind_interdomain {
-	unsigned int remote_domain, remote_port;
-};
-
-/*
- * Allocate a fresh port for binding to @remote_domain.
- * Return allocated port.
- */
-#define IOCTL_EVTCHN_BIND_UNBOUND_PORT			\
-	_IOC(_IOC_NONE, 'E', 2, sizeof(struct ioctl_evtchn_bind_unbound_port))
-struct ioctl_evtchn_bind_unbound_port {
-	unsigned int remote_domain;
-};
-
-/*
- * Unbind previously allocated @port.
- */
-#define IOCTL_EVTCHN_UNBIND				\
-	_IOC(_IOC_NONE, 'E', 3, sizeof(struct ioctl_evtchn_unbind))
-struct ioctl_evtchn_unbind {
-	unsigned int port;
-};
-
-/*
- * Unbind previously allocated @port.
- */
-#define IOCTL_EVTCHN_NOTIFY				\
-	_IOC(_IOC_NONE, 'E', 4, sizeof(struct ioctl_evtchn_notify))
-struct ioctl_evtchn_notify {
-	unsigned int port;
-};
-
-/* Clear and reinitialise the event buffer. Clear error condition. */
-#define IOCTL_EVTCHN_RESET				\
-	_IOC(_IOC_NONE, 'E', 5, 0)
-
-#endif /* __LINUX_PUBLIC_EVTCHN_H__ */
+#include "public/evtchn.h"
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ 12.3/include/uapi/xen/gntdev.h	2012-10-31 16:43:08.000000000 +0100
@@ -0,0 +1 @@
+#include "public/gntdev.h"
--- 12.3.orig/include/uapi/xen/privcmd.h	2012-10-23 15:44:46.000000000 +0200
+++ 12.3/include/uapi/xen/privcmd.h	2012-10-31 16:43:05.000000000 +0100
@@ -1,3 +1 @@
-#if defined(CONFIG_PARAVIRT_XEN) || !defined(__KERNEL__)
 #include "public/privcmd.h"
-#endif
--- 12.3.orig/include/uapi/xen/public/privcmd.h	2011-02-01 15:09:47.000000000 +0100
+++ 12.3/include/uapi/xen/public/privcmd.h	2012-10-30 08:46:17.000000000 +0100
@@ -35,6 +35,7 @@
 
 #include <linux/types.h>
 #include <linux/compiler.h>
+#include <xen/interface/xen.h>
 
 typedef struct privcmd_hypercall
 {
@@ -58,9 +59,13 @@ typedef struct privcmd_mmapbatch {
 	int num;     /* number of pages to populate */
 	domid_t dom; /* target domain */
 	__u64 addr;  /* virtual address */
-	xen_pfn_t __user *arr; /* array of mfns - top nibble set on err */
+	xen_pfn_t __user *arr; /* array of mfns - or'd with
+				  PRIVCMD_MMAPBATCH_*_ERROR on err */
 } privcmd_mmapbatch_t; 
 
+#define PRIVCMD_MMAPBATCH_MFN_ERROR     0xf0000000U
+#define PRIVCMD_MMAPBATCH_PAGED_ERROR   0x80000000U
+
 typedef struct privcmd_mmapbatch_v2 {
 	unsigned int num; /* number of pages to populate */
 	domid_t dom;      /* target domain */
@@ -80,6 +85,15 @@ typedef struct privcmd_mmapbatch_v2 {
 	_IOC(_IOC_NONE, 'P', 2, sizeof(privcmd_mmap_t))
 #define IOCTL_PRIVCMD_MMAPBATCH					\
 	_IOC(_IOC_NONE, 'P', 3, sizeof(privcmd_mmapbatch_t))
+/*
+ * @cmd: IOCTL_PRIVCMD_MMAPBATCH_V2
+ * @arg: &struct privcmd_mmapbatch_v2
+ * Return: 0 on success (i.e., arg->err contains valid error codes for
+ * each frame).  On an error other than a failed frame remap, -1 is
+ * returned and errno is set to EINVAL, EFAULT etc.  As an exception,
+ * if the operation was otherwise successful but any frame failed with
+ * -ENOENT, then -1 is returned and errno is set to ENOENT.
+ */
 #define IOCTL_PRIVCMD_MMAPBATCH_V2				\
 	_IOC(_IOC_NONE, 'P', 4, sizeof(privcmd_mmapbatch_v2_t))
 
--- 12.3.orig/include/xen/evtchn.h	2012-10-23 15:56:48.000000000 +0200
+++ 12.3/include/xen/evtchn.h	2012-10-31 16:34:49.000000000 +0100
@@ -1,3 +1,6 @@
+#ifdef CONFIG_PARAVIRT_XEN
+#include <xen/public/evtchn.h>
+#else
 /******************************************************************************
  * evtchn.h
  * 
@@ -180,3 +183,4 @@ static inline void xen_spin_irq_exit(voi
 #endif
 
 #endif /* __ASM_EVTCHN_H__ */
+#endif /* CONFIG_PARAVIRT_XEN */
--- 12.3.orig/include/xen/gntdev.h	2011-04-13 14:08:57.000000000 +0200
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,3 +0,0 @@
-#if defined(CONFIG_PARAVIRT_XEN) || !defined(__KERNEL__)
-#include "public/gntdev.h"
-#endif
--- 12.3.orig/include/xen/hvm.h	2011-02-01 15:04:27.000000000 +0100
+++ 12.3/include/xen/hvm.h	2012-11-14 13:31:31.000000000 +0100
@@ -7,6 +7,37 @@
 #include <asm/xen/hypercall.h>
 #endif
 
+static inline const char *param_name(int op)
+{
+#define PARAM(x) [HVM_PARAM_##x] = #x
+	static const char *const names[] = {
+		PARAM(CALLBACK_IRQ),
+		PARAM(STORE_PFN),
+		PARAM(STORE_EVTCHN),
+		PARAM(PAE_ENABLED),
+		PARAM(IOREQ_PFN),
+		PARAM(BUFIOREQ_PFN),
+		PARAM(TIMER_MODE),
+		PARAM(HPET_ENABLED),
+		PARAM(IDENT_PT),
+		PARAM(DM_DOMAIN),
+		PARAM(ACPI_S_STATE),
+		PARAM(VM86_TSS),
+		PARAM(VPT_ALIGN),
+		PARAM(CONSOLE_PFN),
+		PARAM(CONSOLE_EVTCHN),
+	};
+#undef PARAM
+
+	if (op >= ARRAY_SIZE(names))
+		return "unknown";
+
+	if (!names[op])
+		return "reserved";
+
+	return names[op];
+}
+
 static inline int hvm_get_parameter(int idx, uint64_t *value)
 {
 	struct xen_hvm_param xhv;
@@ -16,7 +47,8 @@ static inline int hvm_get_parameter(int 
 	xhv.index = idx;
 	r = HYPERVISOR_hvm_op(HVMOP_get_param, &xhv);
 	if (r < 0) {
-		pr_err("Cannot get hvm parameter %d: %d!\n", idx, r);
+		pr_err("Cannot get hvm parameter %s (%d): %d!\n",
+		       param_name(idx), idx, r);
 		return r;
 	}
 	*value = xhv.value;
--- 12.3.orig/include/xen/interface/grant_table.h	2012-12-18 12:11:55.000000000 +0100
+++ 12.3/include/xen/interface/grant_table.h	2012-12-18 12:15:41.000000000 +0100
@@ -390,7 +390,7 @@ struct gnttab_setup_table {
     uint32_t nr_frames;
     /* OUT parameters. */
     int16_t  status;              /* => enum grant_status */
-#if __XEN_INTERFACE_VERSION__ < 0x00040300
+#if !defined(CONFIG_PARAVIRT_XEN) && __XEN_INTERFACE_VERSION__ < 0x00040300
     XEN_GUEST_HANDLE(ulong) frame_list;
 #else
     XEN_GUEST_HANDLE(xen_pfn_t) frame_list;
--- 12.3.orig/include/xen/interface/xen.h	2012-12-18 12:11:14.000000000 +0100
+++ 12.3/include/xen/interface/xen.h	2012-10-29 17:13:41.000000000 +0100
@@ -28,9 +28,6 @@
 #define __XEN_PUBLIC_XEN_H__
 
 #include "xen-compat.h"
-#ifdef CONFIG_PARAVIRT_XEN
-#include <asm/pvclock-abi.h>
-#endif
 
 #if defined(CONFIG_PARAVIRT_XEN) && !defined(HAVE_XEN_PLATFORM_COMPAT_H)
 #include <asm/xen/interface.h>
--- 12.3.orig/lib/swiotlb-xen.c	2012-04-11 13:26:23.000000000 +0200
+++ 12.3/lib/swiotlb-xen.c	2012-10-29 17:13:41.000000000 +0100
@@ -208,7 +208,7 @@ void __init swiotlb_init_with_tbl(char *
  * Statically reserve bounce buffer space and initialize bounce buffer data
  * structures for the software IO TLB used to implement the DMA API.
  */
-void __init
+static void __init
 swiotlb_init_with_default_size(size_t default_size, int verbose)
 {
 	unsigned long bytes;
--- 12.3.orig/mm/memory.c	2013-11-27 11:30:21.000000000 +0100
+++ 12.3/mm/memory.c	2013-11-27 11:33:34.000000000 +0100
@@ -825,7 +825,7 @@ struct page *vm_normal_page(struct vm_ar
 check_pfn:
 	if (unlikely(pfn > highest_memmap_pfn)) {
 #ifdef CONFIG_XEN
-		if (!(vma->vm_flags & VM_RESERVED))
+		if (!(vma->vm_flags & VM_DONTEXPAND))
 #endif
 		print_bad_pte(vma, addr, pte, NULL);
 		return NULL;
